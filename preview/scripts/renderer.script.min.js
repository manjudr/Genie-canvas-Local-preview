AppConfig = {
    version: "BUILD_NUMBER",
    processing_timeout: 10, // in minutes
    host: "",
    recorder: "AUDIO_RECORDER",
    flavor: "DEPLOYMENT",
    heartBeatTime:180000,
    s3ContentHost: "/assets/public/content/",
    previewPluginspath: "/content-plugins",
    devicePluginspath: "/widgets/content-plugins",
    corePluginspath: 'coreplugins',
    apislug: '/action',
    telemetryEventsConfigFields: ['sid', 'uid','did', 'channel', 'etags', 'pdata', 'cdata', 'app', 'dims', 'partner'],
    configFields: ['origin', 'contentId', 'appInfo', 'languageInfo', 'contentExtras', 'appQualifier', 'mode', 'sid', 'uid', 'did', 'channel', 'etags', 'pdata', 'cdata', 'contentLaunchers', 'overlay', 'splash', 'showEndPage', 'app', 'dims', 'partner'],
    mimetypes: [
        "application/vnd.ekstep.ecml-archive", "application/vnd.ekstep.html-archive", "application/vnd.ekstep.h5p-archive", "application/epub", "video/mp4", "application/pdf","video/x-youtube","video/webm"
    ],
    defaultMetadata: {
        "identifier": "org.ekstep.item.sample",
        "mimeType": "application/vnd.ekstep.ecml-archive",
        "name": "Content Preview ",
        "author": "EkStep",
        "localData": {
            "name": "Content Preview ",
            "loadingMessage": "Without requirements or design, programming is the art of adding bugs to an empty text file. ...",
            "identifier": "org.ekstep.item.sample",
            "pkgVersion": 1
        },
        "isAvailable": true,
        "path": ""
    },
    contentLaunchers: [
        {
            mimeType: ['application/vnd.ekstep.html-archive', 'application/vnd.ekstep.h5p-archive'],
            id: 'org.ekstep.htmlrenderer',
            ver: 1.0,
            type: 'plugin'
        }, {
            mimeType: ['application/vnd.ekstep.ecml-archive'],
            id: 'org.ekstep.ecmlrenderer',
            ver: 1.0,
            type: 'plugin'
        },
        {
            mimeType: ['application/epub'],
            id: 'org.ekstep.epubrenderer',
            ver: 1.0,
            type: 'plugin'
        },
        {
            mimeType: ['video/mp4', 'video/x-youtube', 'video/webm'],
            id: 'org.ekstep.videorenderer',
            ver: 1.0,
            type: 'plugin'
        },
        {
            mimeType: ['application/pdf'],
            id: 'org.ekstep.pdfrenderer',
            ver: 1.0,
            type: 'plugin'
        }
    ],
    assetbase: 'assets/icons/',
    defaultPlugins: [
        {
            id: 'org.ekstep.launcher',
            ver: 1.0,
            type: 'plugin'
        }, {
            id: 'org.ekstep.repo',
            ver: 1.0,
            type: 'plugin'
        },{
            id:"org.ekstep.telemetrysync",
            ver:1.0,
            type:'plugin'
        }
    ],
    overlay: {
        enableUserSwitcher: true,
        showUser: true,
        showOverlay: true,
        showNext: true,
        showPrevious: true,
        showSubmit: false,
        showReload: true,
        showContentClose: false,
        menu: {
            showTeachersInstruction: true
        }
    },
    splash: {
        text: "Powered by EkStep",
        icon: "assets/icons/icn_genie.png",
        bgImage: "assets/icons/background_1.png",
        webLink: "https://www.ekstep.in"
    },
    showEndPage: true,
    pdata: {'id':'in.ekstep', 'ver':'1.0'},
    channel: "in.ekstep",
    etags: {
        app: [],
        partner: [],
        dims: []
    },
    context: {},
    config: {}
}

GlobalContext = {
    user: {},
    game: {
        id: "",
        ver: ""
    },
    _params: {},
    config: {
        origin: "",
        contentId: "",
        flavor: "",
        appInfo: undefined
    },
    filter: undefined,
    init: function(gid, ver) {
        return new Promise(function(resolve, reject) {
            GlobalContext.game.id = gid;
            GlobalContext.game.ver = ver;
            GlobalContext._setGlobalContext(resolve, reject);
        });
    },
    _setGlobalContext: function(resolve, reject) {
        new Promise(function(resolve, reject) {
            if (window.plugins && window.plugins.webintent) {
                var promises = [];
                for (var i = 0; i < AppConfig.configFields.length; i++) {
                    promises.push(GlobalContext._getIntentExtra(AppConfig.configFields[i], GlobalContext.config));
                }
                Promise.all(promises).then(function(result) {
                    setGlobalConfig(GlobalContext.config);
                    org.ekstep.service.renderer.initializeSdk(GlobalContext.config.appQualifier || 'org.ekstep.genieservices');
                    if (GlobalContext.config.appInfo) {
                        GlobalContext.game.id = GlobalContext.config.appInfo.identifier;
                        GlobalContext.game.ver = GlobalContext.config.appInfo.pkgVersion || "1";
                        GlobalContext.game.contentExtras = GlobalContext.config.contentExtras;

                        for (var i = 0; i < AppConfig.telemetryEventsConfigFields.length; i++) {
                            GlobalContext._params[AppConfig.telemetryEventsConfigFields[i]] = GlobalContext.config[AppConfig.telemetryEventsConfigFields[i]];
                        }

                        // GlobalContext.config.contentExtras.switchingUser = true;`
                        // Assuming filter is always an array of strings.
                        GlobalContext.filter = (GlobalContext.config.appInfo.filter)
                            ? JSON.parse(GlobalContext.config.appInfo.filter)
                            : GlobalContext.config.appInfo.filter;
                    }
                }).then(function() {
                    if (GlobalContext.config.appInfo && COLLECTION_MIMETYPE == GlobalContext.config.appInfo.mimeType && null == GlobalContext.filter) {
                        org.ekstep.service.renderer.getContent(GlobalContext.config.appInfo.identifier).then(function(result) {
                            if (result.isAvailable) {
                                GlobalContext.config.appInfo = result.localData || result.serverData;
                                resolve(GlobalContext.config);
                            } else {
                                reject('CONTENT_NOT_FOUND');
                            }
                        }).catch(function(err) {
                            console.error(err);
                            reject('CONTENT_NOT_FOUND');
                        });
                    } else {
                        resolve(GlobalContext.config);
                    }
                });
            } else {
                // TODO: Only for the local
                if (!isbrowserpreview) {
                    GlobalContext.config = {
                        origin: "Genie",
                        contentId: "org.ekstep.num.addition.by.grouping",
                        appInfo: {
                            code: "org.ekstep.quiz.app",
                            mimeType: "application/vnd.android.package-archive",
                            identifier: "org.ekstep.quiz.app"
                        }
                    };
                    window.globalConfig = mergeJSON(GlobalContext.config, AppConfig);
                    GlobalContext.config = window.globalConfig;
                    resolve(GlobalContext.config);
                }
            }
        }).then(function(config) {
            // GlobalContext.config = config = { origin: "Genie", contentId: "org.ekstep.num.addition.by.grouping"};
            if (config && config.origin == 'Genie') {
                return org.ekstep.service.renderer.getCurrentUser();
            } else {
                reject('INVALID_ORIGIN');
            }
        }).then(function(result) {
            // GlobalContext.user = result;
            // if (result && result.status == 'success') {
            if (result.uid) {
                GlobalContext.user = result;
                GlobalContext._params.user = GlobalContext.user;
                resolve(true);
            } else {
                reject('INVALID_USER');
            }
            // } else {
            //     reject('INVALID_USER');
            // }
        }).catch(function(err) {
            reject(err);
        });
    },
    _getIntentExtra: function(param, contextObj) {
        return new Promise(function(resolve, reject) {
            window.plugins.webintent.getExtra(param, function(url) {
                if (url) {
                    try {
                        contextObj[param] = JSON.parse(url);
                    } catch(e) {
                        contextObj[param] = url;
                    }
                }
                resolve(true);
            }, function(e) {
                console.log('intent value not set for: ' + param);
                resolve(true);
            });
        });
    },
    setParam: function(param, value, incr, max) {
        if (param != 'user') {
            var fval = GlobalContext._params[param];
            if (incr) {
                if (!fval)
                    fval = 0;
                fval = (fval + incr);
            } else {
                fval = value
            }
            if (0 > fval)
                fval = 0;
            if ("undefined" != typeof max && fval >= max)
                fval = 0;
            GlobalContext._params[param] = fval;
        } else {
            console.error('user param can not set');
        }
    },
    getParam: function(param) {
        return GlobalContext._params[param];
    }
};

AppMessages = {
	NO_CONTENT_LIST_FOUND: "There are no stories or worksheets available in this collection. You can always download new ones !",
	NO_CONTENT_FOUND: "There is no content available. You can always download !",
	SUCCESS_GET_CONTENT_LIST: "Content list synced.",
	ERR_GET_CONTENT_LIST: "Error while getting content list. Please try again.",
	CONTENT_LOAD_MSG: "{0} downloaded to bookshelf",
	NO_NEW_CONTENT: "No new content available in the repository",
	DOWNLOADING_MSG: "Downloading {0} content items",
	NO_CONNECTION_ERROR: "Unable to connect to the content repository.<br/>Please check your internet connectivity and try again.",
	INTERNAL_ERROR: "Something went wrong.<br/>Please try again later or contact helpdesk if issue persists.",
	SYSTEM_ERROR: "System Error occured: {0}.<br/>Please try again later or contact helpdesk if issue persists.",
	DOWNLOAD_ERROR: "Error downloading content: {0}",
	DOWNLOAD_URL_ERROR: "Invalid download URL for content: {0}",
	EXTRACT_FILE_NOT_FOUND: "Error extracting content. File not found: {0}",
	EXTRACT_INVALID_OUPUT_DIR: "Error extracting content. Output directory not found: {0}",
	EXTRACT_INVALID_ARCHIVE: "Invalid Content Archive File",
	DIRECT_DOWNLOADING_MSG: "Content is downloading...",
	DIRECT_CONTENT_LOAD_MSG: "Content downloading complete",
	ERR_FETCHING_CONTENT_PATH: "Error while getting content. Please try again."
};

var AppErrors = {
	contentListFetch: 'Error while fetching content list: ',
	contentListFilterFetch: 'Error while fetching and filtering content list: ',
	contetnPathFetch: 'Error while fetching content path: ',
	sendFeedbackStatus: 'Unable to send feedback event'
};

var AppLables = {
    "languageCode": "en",
    "home": "Home",
    "title": "TITLE",
    "submit": "SUBMIT",
    "image": "Image",
    "voice": "Voice",
    "audio": "Audio",
    "author": "Author",
    "instructions": "Teacher's Note",
    "feedback": "Feedback",
    "noCreditsAvailable": "There are no credits available",
    "congratulations": "Congratulations! You just completed",
    "credit": "Credits",
    "next": "Next",
    "scores": "SCORES AND RATING",
    "lastPage": "GO TO LAST PAGE",
    "nextContent": "NEXT CONTENT",
    "comment": "write your comment...",
    "mute": "on",
    "change": "Change",
	"replay": "Replay",
	"continue": "Continue",
    "group": "Group",
    "child": "Child",
    "groupFallbackText": "You have not created any group",
    "userSwitcherTitle": "Select a child or a group",
    "anonymousUserName": "Anonymous",
	"backButtonText": "Would you like to leave this content ?",
	"tryAgain": "Try Again",
	
}

var splashScreen = {
    elementId: '#loading',
    config: {
        text: "Powered by EkStep Genie",
        icon: "img/icons/icn_genie.png",
        bgImage: "img/icons/background_1.png",
        webLink: "https://www.ekstep.in"
    },
    progressEle:undefined,
    initialize: function() {
        var appConfigKeys = Object.keys(AppConfig.splash);

        for (var i = 0; i < appConfigKeys.length; i++) {
            var objKey = appConfigKeys[i];
            splashScreen.config[objKey] = GlobalContext.config[objKey] || AppConfig.splash[objKey];
        };
        var html = this.createHtml();
        jQuery(this.elementId).html(html);
        // add event listener for hide and show of splash splashScreen
        var instance = this;
        var elem = document.getElementById('splashScreen');
        elem.onclick = function() {
            instance.launchPortal();
        };

        instance.show();
    },
    addEvents: function(){
        EkstepRendererAPI.addEventListener("renderer:launcher:load", splashScreen.loadContentDetails);
        EkstepRendererAPI.addEventListener("renderer:splash:show", splashScreen.show);
        EkstepRendererAPI.addEventListener("renderer:splash:hide", splashScreen.hide);
        EkstepRendererAPI.addEventListener("renderer:content:start", splashScreen.hide);
    },
    createHtml: function() {
        var html = '<img src=' + splashScreen.config.bgImage + ' class="gc-loader-img" /><P class="splashText" id="splashTextId"> Loading your content ... </p><div id="progressArea"><div id="progressBar"></div><p id="progressCount" class="font-lato gc-loader-prog"></p></div><a href="' + splashScreen.config.webLink + '" target="_blank"><div id="splashScreen" class="splashScreen"> <img src=' + splashScreen.config.icon + ' class="splash-icon " /> <span>' + splashScreen.config.text + '</span> </div></a>';
        return html;
    },

    launchPortal: function() {
        if (window.cordova) {
            var url = splashScreen.config.webLink;
            genieservice.launchPortal(url);
        }
    },

    loadContentDetails: function(eve, data) {
        console.log("loadContentDetails data: ", data);
        $("#splashTextId").text(data.name);
    },

    show: function() {
        jQuery(splashScreen.elementId).show();
        splashScreen.showProgressBar();

    },

    hide: function(event) {
        jQuery(splashScreen.elementId).hide();
        splashScreen.hideProgressBar();
    },

    showProgressBar: function() {
        splashScreen.progressEle = document.getElementById("progressBar");
        jQuery("#progressBar").width(0);
        jQuery('#loading').show();
        var width = 1;
        clearInterval(id);
        var id = setInterval(frame, 50);
        function frame() {
            if (width >= 100) {
                clearInterval(id);
            } else {
                width++;
                if (splashScreen.progressEle && splashScreen.progressEle.style)
                    splashScreen.progressEle.style.width = width + '%';
                jQuery('#progressCount').text(width + '%');
            }
        }

    },

    hideProgressBar:function() {
    //   splashScreen.progressEle.style.width = 0 + '%'
      jQuery('#loading').hide();
    }
};
// splashScreen.initialize();

var packageName = "org.ekstep.quiz.app", version = AppConfig.version, packageNameDelhi = "org.ekstep.delhi.curriculum",
    geniePackageName = "org.ekstep.genieservices", currentUser = {}, userList = [],
    COLLECTION_MIMETYPE = "application/vnd.ekstep.content-collection",
    stack = new Array(), collectionChildrenIds = new Array(), collectionPath = new Array(), collectionPathMap = {},
    collectionChildren = true, content = {}, config = {showEndPage: true, showHTMLPages: true },
    isbrowserpreview = getUrlParameter("webview"), isCoreplugin = undefined, Renderer = undefined;

document.body.addEventListener("logError", telemetryError, false);

// Create IE + others compatible event handler
var eventMethod = window.addEventListener ? "addEventListener" : "attachEvent";
var eventer = window[eventMethod];
var messageEvent = eventMethod == "attachEvent" ? "onmessage" : "message";

// Listen to message from child window
eventer(messageEvent,function(e) {
  console.info('parent received message!:  ',e.data);
},false);

function telemetryError(e) {
    var $body = angular.element(document.body);
    var $rootScope = $body.scope().$root;
    document.body.removeEventListener("logError",e);
}
function removeRecordingFiles(path) {
    _.each(RecorderManager.mediaFiles, function(path) {
        $cordovaFile.removeFile(cordova.file.dataDirectory, path)
            .then(function(success) {
                console.log("success : ", success);
            }, function(error) {
                console.log("err : ", error);
            });
    })
}

function createCustomEvent(evtName, data) {
    var evt = new CustomEvent(evtName, data);
}

function imageExists(url, callback, index) {
    var img = new Image();
    img.onload = function() { callback(true, index); };
    img.onerror = function() { callback(false, index); };
    img.src = url;
}

function getUrlParameter(sParam) {
    var sPageURL = decodeURIComponent(window.location.search.substring(1)),
        sURLVariables = sPageURL.split('&'),
        sParameterName,
        i;
    for (i = 0; i < sURLVariables.length; i++) {
        sParameterName = sURLVariables[i].split('=');

        if (sParameterName[0] === sParam) {
            return sParameterName[1] === undefined ? true : sParameterName[1];
        }
    }
}

function getCurrentStageId() {
    var stageId = EkstepRendererAPI.getCurrentStageId();
    return (stageId) ? stageId : angular.element(document).scope().pageId;
}

function backbuttonPressed(stageId) {
    TelemetryService.interrupt("OTHER", stageId);

    // var telemetryEndData = {};
    // telemetryEndData.stageid = getCurrentStageId();
    // telemetryEndData.progress = logContentProgress();
    // TelemetryService.end(telemetryEndData);
    EkstepRendererAPI.dispatchEvent('renderer:telemetry:end');
    try {
        TelemetryService.exit(stageId);
    } catch (err) {
        console.error('End telemetry error:', err.message);
    }
    localStorageGC.clear();
    localStorageGC = {};
    org.ekstep.service.renderer.endGenieCanvas();
}

// TODO: After integration with Genie, onclick of exit we should go to previous Activity of the Genie.
// So, change exitApp to do the same.
function exitApp(stageId) {
    if(!stageId){
        stageId = !_.isUndefined(Renderer) ? Renderer.theme._currentStage : " ";
    }
    try {
        TelemetryService.exit(stageId);
    } catch (err) {
        console.error('End telemetry error:', err.message);
    }
    localStorageGC.clear();
    localStorageGC = {};
    org.ekstep.service.renderer.endGenieCanvas();
}

function startApp(app) {
    if (!app) app = geniePackageName;
    if (!_.isUndefined(navigator) && !_.isUndefined(navigator.startApp)) {
        navigator.startApp.start(app, function(message) {
            exitApp();
            TelemetryService.exit(getCurrentStageId())
            // TelemetryService.exit(packageName, version)
        }, function(error) {
            if (app == geniePackageName)
                showToaster('error', "Unable to start Genie App.");
            else {
                var bool = confirm('App not found. Do you want to search on PlayStore?');
                if (bool) cordova.plugins.market.open(app);
            }
        });
    }
}

function contentNotAvailable(error) {
    EkstepRendererAPI.logErrorEvent(error,{'type':'content','action':'play','severity':'fatal'});
    showToaster('error', AppMessages.NO_CONTENT_FOUND);
    exitApp();
}

function checkStage(showalert) {
    if (GlobalContext.config.appInfo.mimeType == 'application/vnd.ekstep.content-collection') {
        if (showalert == "showAlert") {
            showToaster("error", "No stage found, redirecting to collection list page")
        }
        exitApp();
    } else {
        if (showalert == "showAlert") {
            showToaster("error", "No Stage found, existing canvas")
        }
        exitApp();
    }
    Renderer.running = false;
    return
}

function objectAssign() {
    Object.assign = function(target) {
        if (target === undefined || target === null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }
        var output = Object(target);
        _.each(arguments, function(argument) {
            if (argument !== undefined && argument !== null) {
                for (var nextKey in argument) {
                    if (argument.hasOwnProperty(nextKey)) {
                        output[nextKey] = argument[nextKey];
                    }
                }
            }
        })
        return output;
    }
}

/*TODO: Need to Remove the LocalStorage Logic
Now HTML Contetnts are opening inside iframe */
var localStorageGC = {
    name: 'canvasLS',
    isHtmlContent: false,
    isCollection: false,
    content: {},
    collection: {},
    telemetryService: {},
    setItem: function(param, data) {
        if (data) {
            this[param] = _.isString(data) ? data : JSON.stringify(data);
        }
    },
    getItem: function(param) {
        if (param) {
            var paramVal = this[param];
            paramVal = _.isEmpty(paramVal) ? {} : JSON.parse(paramVal);
            return paramVal;
        } else {
            return;
        }
    },
    removeItem: function(param) {
        this[param] = {};
        //localStorage.removeItem(canvasLS.param);
    },
    save: function() {
        // Storing into localStorage
        var thisData = {};
        thisData.content = this.content;
        thisData.collection = this.collection;
        thisData.telemetryService = this.telemetryService;
        thisData.isCollection = this.isCollection;
        thisData.isHtmlContent = this.isHtmlContent;

        localStorage.setItem(this.name, JSON.stringify(thisData));
    },
    clear: function() {
        localStorage.removeItem(this.name);
    },
    update: function() {
        //gettting from localstorage and updating all its values
        var lsData = localStorage.getItem(this.name);
        if (lsData) {
            lsData = JSON.parse(lsData);
            var lsKeys = _.keys(lsData);
            var instance = this;
            _.each(lsKeys, function(key) {
                instance.setItem(key, lsData[key]);
            })
        }
    }
}

function startTelemetry(id, ver, cb) {
    localStorageGC.removeItem("telemetryService");
    var correlationData = [];
    if (!_.isEmpty(GlobalContext.game.contentExtras) && !_.isUndefined(GlobalContext.game.contentExtras)) {
        GlobalContext.game.contentExtras = ("string" == typeof(GlobalContext.game.contentExtras)) ? JSON.parse(GlobalContext.game.contentExtras) : GlobalContext.game.contentExtras;
        correlationData.push(GlobalContext.game.contentExtras);
    }
    var otherData = GlobalContext.config.otherData;
    if (!_.isUndefined(otherData) && !_.isUndefined(otherData.cdata)) {
        _.each(otherData.cdata, function(cdata) {
            correlationData.push(cdata);
        })
        delete otherData.cdata;
    }
    correlationData.push({"id": CryptoJS.MD5(Math.random().toString()).toString(), "type": "ContentSession"});
    TelemetryService.init(GlobalContext.game, GlobalContext.user, correlationData, otherData).then(function(response) {
        TelemetryService.eventDispatcher = EkstepRendererAPI.dispatchEvent;
        var data = {};
        data.stageid = EkstepRendererAPI.getCurrentStageId();
        data.mode =  getPreviewMode();
        TelemetryService.start(id, ver, data);
        if (!_.isUndefined(TelemetryService.instance)) {
            var tsObj = _.clone(TelemetryService);
            tsObj._start = JSON.stringify(tsObj.instance._start);
            tsObj._end = JSON.stringify(tsObj.instance._end);
            localStorageGC.setItem("telemetryService", tsObj);
            localStorageGC.save();
        }
        if (!_.isUndefined(cb) && response == true) {
            cb();
        }
    }).catch(function(error) {
        EkstepRendererAPI.logErrorEvent(error, {'type':'system','action':'play','severity':'fatal'});
        showToaster('error', 'TelemetryService init failed.');
        exitApp();
    });
}

function getAsseturl(content) {
    var content_type = content.mimeType == 'application/vnd.ekstep.html-archive' ? "html/" : "ecml/";
    var globalConfig = EkstepRendererAPI.getGlobalConfig();
    var path = window.location.origin + globalConfig.s3ContentHost + content_type;
    path += content.status == "Live" ? content.identifier + "-latest" : content.identifier + "-snapshot";
    return path;

}
//ref: http://www.jqueryscript.net/other/Highly-Customizable-jQuery-Toast-Message-Plugin-Toastr.html
function showToaster(toastType, message, customOptions) {
    var defaultOptions = {"positionClass": "toast-top-right", "preventDuplicates": true, "tapToDismiss": true, "hideDuration": "1000", "timeOut": "4000", };
    toastr.options = _.extend(defaultOptions, customOptions);
    if (toastType === 'warning') {
        toastr.warning(message);
    }
    if (toastType === 'error') {
        toastr.error(message);
    }
    if (toastType === 'info') {
        toastr.info(message);
    }
}

function addWindowUnloadEvent() {
    // TODO: Use Iframe unload event
    window.onbeforeunload = function(e) {
        e = e || window.event;
        var y = e.pageY || e.clientY;
        !y && EkstepRendererAPI.getTelemetryService().interrupt('OTHER', EkstepRendererAPI.getCurrentStageId()); EkstepRendererAPI.dispatchEvent("renderer:content:close");
    };
    if (EkstepRendererAPI.getGlobalConfig().context.mode === 'edit') {
        parent.document.getElementsByTagName('iframe')[0].contentWindow.onunload = function() {
            EkstepRendererAPI.getTelemetryService().interrupt('OTHER', EkstepRendererAPI.getCurrentStageId());
            EkstepRendererAPI.dispatchEvent("renderer:content:close");
        }
    }
}

function compareObject(obj1, obj2) {
    //Loop through properties in object 1
    for (var p in obj1) {
        //Check property exists on both objects
        if (obj1.hasOwnProperty(p) !== obj2.hasOwnProperty(p)) return false;

        switch (typeof (obj1[p])) {
            //Deep compare objects
            case 'object':
                if (!Object.compare(obj1[p], obj2[p])) return false;
                break;
            //Compare function code
            case 'function':
                if (typeof (obj2[p]) == 'undefined' || (p != 'compare' && obj1[p].toString() != obj2[p].toString())) return false;
                break;
            //Compare values
            default:
                if (obj1[p] != obj2[p]) return false;
        }
    }

    //Check object 2 for any extra properties
    for (var p in obj2) {
        if (typeof (obj1[p]) == 'undefined') return false;
    }
    return true;
}

function getPreviewMode() {
   var mode = 'preview';
    if ("undefined" != typeof cordova) {
        mode = !_.isUndefined(GlobalContext.config.mode) ? GlobalContext.config.mode : 'play';
    } else if (EkstepRendererAPI.getGlobalConfig().context.mode) {
        mode = EkstepRendererAPI.getGlobalConfig().context.mode;
    }
    return mode;
}

function logContentProgress(value) {
    if (_.isUndefined(value)) {
        if (!_.isUndefined(Renderer)) {
            var stageLenth = Renderer.theme._data.stage.length;
            var currentIndex = _.findIndex(Renderer.theme._data.stage, {
                id: Renderer.theme._currentScene.id
            });
            currentIndex = currentIndex + 1;
            return (currentIndex / stageLenth) * 100;
        } else {
            return 100;
        }
    } else {
        return value;
    }
}

function setGlobalConfig(context) {
    GlobalContext.config  = mergeJSON(AppConfig, context);
    window.globalConfig = GlobalContext.config;

    if (_.isUndefined(window.cordova)) {
        org.ekstep.service.renderer.api.setBaseUrl(window.globalConfig.host + window.globalConfig.apislug);
    }
    setTelemetryEventFields(window.globalConfig);
    splashScreen.initialize();
}

function setTelemetryEventFields(globalConfig) {
    var otherData = {};
    for (var i = 0; i < globalConfig.telemetryEventsConfigFields.length; i++) {
        var value = globalConfig[globalConfig.telemetryEventsConfigFields[i]] || globalConfig[globalConfig.telemetryEventsConfigFields[i]];
        var key = globalConfig.telemetryEventsConfigFields[i];
        if (!_.isUndefined(value)) otherData[key] = value;
    }
    var etags = {
        'dims':otherData.dims || AppConfig.etags.dims,
        'app':otherData.app || AppConfig.etags.app,
        'partner':otherData.partner ||  AppConfig.etags.partner
    };
    otherData.etags = etags;
    delete otherData.dims;
    delete otherData.app;
    delete otherData.partner;
    GlobalContext.config.otherData = otherData;
}

function mergeJSON(a, b) {
    // create new object and copy the properties of first one
    var res = _.clone(a);
    //iterate over the keys of second object
    Object.keys(b).forEach(function(e) {
        // check key is present in first object
        // check type of both value is object(not array) and then
        // recursively call the function
        if (e in res && typeof res[e] == 'object' && typeof res[e] == 'object' && !(Array.isArray(res[e]) || Array.isArray(b[e]))) {
            // recursively call the function and update the value
            // with the returned ne object
            res[e] = mergeJSON(res[e], b[e]);
        } else {
            // otherwise define the preperty directly
            if ((Array.isArray(res[e]) && Array.isArray(b[e]))) {
                res[e] = _.union(res[e], b[e]);
            } else {
                res[e] = b[e];
            }
        }
    });
    return res;
}

// Ionic Quiz App

// angular.module is a global place for creating, registering and retrieving Angular modules
// 'quiz' is the name of this angular module example (also set in a <body> attribute in index.html)
// the 2nd parameter is an array of 'requires'
var app = angular.module('genie-canvas', ['ionic', 'ngCordova', 'oc.lazyLoad'])
    .constant("appConstants", {"contentId": "contentId", "stateContentList": "contentList", "stateShowContent": "showContent", "statePlayContent": "playContent", "stateShowContentEnd": "showContentEnd"})
    .run(function($rootScope, $ionicPlatform, $location, $timeout, $state, $stateParams, appConstants) {
        $rootScope.enableEval = false;
        $rootScope.enableUserSwitcher = undefined;
        $rootScope.showUser = undefined;
        $rootScope.sortingIndex = 0;
        $rootScope.users = [];
        var globalConfig = EkstepRendererAPI.getGlobalConfig();
        // serverPath and localPreview is a global variable defined in index.html file inside a story
        if ("undefined" != typeof localPreview && "local" == localPreview)
            globalConfig.assetbase = serverPath + globalConfig.assetbase;
        $rootScope.safeApply = function(fn) {
            if (this.$root) {
                var phase = this.$root.$$phase;
                if (phase == '$apply' || phase == '$digest') {
                    if (fn && (typeof(fn) === 'function')) {
                        fn();
                    }
                } else {
                    this.$apply(fn);
                }
            }
        };
        $rootScope.addIonicEvents = function() {
            // To override back button behaviour
            $ionicPlatform.registerBackButtonAction(function() {
                if (EkstepRendererAPI.hasEventListener(EkstepRendererEvents['renderer:device:back'])) {
                    EkstepRendererAPI.dispatchEvent(EkstepRendererEvents['renderer:device:back']);
                } else {
                    //TODO: Add Telemetry interact for ok and Cancle
                    var stageId = undefined;
                    var type = undefined;
                    if (Renderer) {
                        AudioManager.stopAll();
                        type = Renderer.running ? 'EXIT_CONTENT' : 'EXIT_APP'
                        stageId = Renderer.theme ? Renderer.theme._currentStage : $rootScope.pageId;
                    } else {
                        type: 'EXIT_CONTENT';
                        stageId = $rootScope.pageId || '';
                    }
                    TelemetryService.interact('TOUCH', 'DEVICE_BACK_BTN', 'EXIT', {type:type,stageId:stageId});
                        if (confirm(AppLables.backButtonText)) {
                        TelemetryService.interact('END', 'ALERT_OK', 'EXIT', {type:type,stageId:stageId});
                            backbuttonPressed(stageId);
                        } else {
                            TelemetryService.interact('TOUCH', 'ALERT_CANCEL', 'EXIT', {type:type,stageId:stageId});
                        }
                }  
            }, 100);
            $ionicPlatform.on("pause", function() {
                Renderer && Renderer.pause();
            });
            $ionicPlatform.on("resume", function() {
                Renderer && Renderer.resume();
            });
        };
        $timeout(function() {
            $ionicPlatform.ready(function() {
                splashScreen.addEvents();
                isMobile = window.cordova ? true : false,
                org.ekstep.service.init();
                if ("undefined" == typeof Promise) {
                    alert("Your device isn’t compatible with this version of Genie.");
                    exitApp();
                }
                $rootScope.addIonicEvents();
                if (window.cordova && window.cordova.plugins.Keyboard) {
                    cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true);
                } else {
                    globalConfig.recorder = "android";
                }
                window.StatusBar && StatusBar.styleDefault();
                GlobalContext.init(packageName, version).then(function(appInfo) {
                    if ("undefined" != typeof localPreview && "local" == localPreview)
                        return;
                    if (!isbrowserpreview) {
                        localStorageGC.setItem("contentExtras", GlobalContext.game.contentExtras);
                        org.ekstep.contentrenderer.device();
                    }
                }).catch(function(res) {
                    console.log("Error Globalcontext.init:", res);
                    EkstepRendererAPI.logErrorEvent(res, {
                        'type': 'system',
                        'severity': 'fatal',
                        'action': 'play'
                    })
                    alert(res.errors);
                    exitApp();
                });
            });

        });
    }).config(function($stateProvider, $urlRouterProvider, $controllerProvider, $compileProvider) {
        app.controllerProvider = $controllerProvider;
        app.compileProvider = $compileProvider;

    }).controller('BaseCtrl', function($scope, $rootScope, $state, $ocLazyLoad, $stateParams, $compile, appConstants) {

        $scope.templates = [];
        function loadNgModules(templatePath, controllerPath, callback) {
            var loadFiles = [];
            if(templatePath){
                if(_.isArray(templatePath)){
                    _.each(templatePath, function(template){
                        loadFiles.push({ type: 'html', path: template });
                    });
                } else {
                    loadFiles.push({ type: 'html', path: templatePath });
                }
            }
            if(controllerPath){
                loadFiles.push({ type: 'js', path: controllerPath });
            }
            $ocLazyLoad.load(loadFiles).then(function(){
                if(!_.isArray(templatePath)){
                    injectTemplates(templatePath);
                }
            });
        };

        function injectTemplates(templatePath, scopeVariable, toElement) {
            $scope.templates.push(templatePath);
            var el = angular.element("content-holder");
            $compile(el.contents())($scope);
            $scope.safeApply();
        }
        EkstepRendererAPI.addEventListener("renderer:add:template", function(event){
            var data = event.target;
            injectTemplates(data.templatePath, data.scopeVariable, data.toElement);
        });


        EkstepRendererAPI.addEventListener("renderer:content:close", function(event, data) {
            if (data && data.interactId) {
                var eventName = 'OE_INTERACT';
                if (TelemetryService.instance) var isTelemetryStartActive = TelemetryService.instance.telemetryStartActive();
                if (!isTelemetryStartActive) {
                    eventName = 'GE_INTERACT'
                }
              TelemetryService.interact("TOUCH", data.interactId, "TOUCH", {
                stageId: EkstepRendererAPI.getCurrentStageId() ? EkstepRendererAPI.getCurrentStageId() : $rootScope.pageId
              }, eventName);
            }
            EkstepRendererAPI.dispatchEvent('renderer:telemetry:end');
            if (data && data.callback) data.callback();
        });

        org.ekstep.service.controller.initService(loadNgModules);
        EkstepRendererAPI.addEventListener("renderer.content.getMetadata", function() {
            var configuration = EkstepRendererAPI.getGlobalConfig();
            content.metadata = (_.isUndefined(configuration.metadata) || _.isNull(configuration.metadata)) ? globalConfig.defaultMetadata : configuration.metadata
            if (_.isUndefined(configuration.data)) {
                org.ekstep.contentrenderer.web(configuration.context.contentId);
            } else {
                content.body = configuration.data;
                org.ekstep.contentrenderer.startGame(content.metadata)
            }
        }, this);
    });

/***
 * The base plugin class that all renderer plugins inherit from. It provides the common support contract for all plugins.
 * Plugins can override specific methods to change the behavior. The most common scenario would be to override the
 * implementation of createJS callback methods to detect interactivity on the canvas.
 *
 * @class EkstepRenderer.Plugin
 * @author Vinu Kumar V.S <vinu.kumar@tarento.com>
 */
var Plugin = Class.extend({
    _isContainer: false,
    _defaultFont: undefined,
    _render: true,
    /**
     * @description A variable which holds _theme instance where this plugin is added.
     * @memberOf EkstepRenderer.Plugin
     */
    _theme: undefined,
    _parent: undefined,
    /**
     * A variable which holds _stage instance where this plugin is added. This is an instance of creatine scene object.
     * @memberOf EkstepRenderer.Plugin
     */
    _stage: undefined,
    /**
     * A variable which holds the data of plugin defined in ECML/JSON.
     * @memberOf EkstepRenderer.Plugin
     */
    _data: undefined,
    _currIndex: 0,
    _index: 0,
    /**
     * A variable _self is a createJS element. Actual instance of createJS element which will render on the stage.
     * @memberOf EkstepRenderer.Plugin
     */
    _self: undefined,
    _dimensions: undefined,
    /**
     * A variable _id is a unique+ idenfier of the plugin
     * @memberOf EkstepRenderer.Plugin
     */
    _id: undefined,
    _childIds: [],
    _enableEvents: true,
    events: [],
    appEvents: [],
    borderShape: undefined,
    _pluginParams: {},
    _manifest: {},
    _unSupportedFonts: ["notosans", "verdana", "notosans oriya"],
    /**
     * Initializes the plugin with the given data and parent object
     * @param data {object} Init parameters for the plugin
     * @param parent {object} Parent plugin instance where this plugin renders
     * @param stage {object} stage intance where this plugin has to renderer
     * @param theme {object} theme/canvas instance of the content
     * @memberof EkstepRenderer.Plugin
     * @instance
     */
    init: function(data, parent, stage, theme) {
        if(arguments.length == 1){
           if(_.isUndefined(data)){
               // To initialize chore & custom plugin global
               this.initialize(data);
               return;
            } else {
               if (!data.canvasId) {
                   // Only plugin manifest is getting(calling by plugin framework)
                   this._manifest = data;
                   this.initialize(data);
                   return;
               }
           }
        }
       try {
            this.events = [];
            this.appEvents = [];
            this._childIds = [];
            this._pluginParams = {};
            this._theme = theme;
            this._stage = stage;
            this._parent = parent;
            this._data = data;
            this.handleFont(data);
            this.initPlugin(data);
            var dims = this.relativeDims();
            if (dims && this._self) {
                this._self.origX = dims.x;
                this._self.origY = dims.y;
                this._self.width = dims.w;
                this._self.height = dims.h;
            }
            if (data.enableDrag) {
                this.enableDrag(this._self, data.snapTo);
            }
            var instance = this;
            if (!_.isUndefined(data.appEvents)) {
                // In New AT the App events are comming as Array of objects
                if (_.isArray(data.appEvents)) {
                    _.each(data.appEvents, function(value, key) {
                        instance.appEvents.push.apply(instance.appEvents, data.appEvents[key].list.split(/[\s,]+/));
                    });
                } else {
                    this.appEvents.push.apply(this.appEvents, data.appEvents.list.split(/[\s,]+/));
                }
            }
            // Allow child classes to disable event registration (e.g. when they use event as a template)
            if (this._enableEvents) {
                EventManager.registerEvents(this, this._data);
            }
            //TODO: Need to remove the _id use only id varible
            this._id = this.id = this._data.id || this._data.asset || _.uniqueId('plugin');
            PluginManager.registerPluginObject(this);
            if (this._self && data.visible === false) {
                this._self.visible = false;
            }

            // Conditional evaluation for rendering
            if (data['ev-if']) {
                var expr = data['ev-if'].trim();
                var modelExpr = expr = this.replaceExpressions(expr);
                if (!(expr.substring(0, 2) == "${")) expr = "${" + expr;
                if (!(expr.substring(expr.length - 1, expr.length) == "}")) expr = expr + "}";
                var exprVal = this.evaluateExpr(expr);
                if (typeof exprVal == "undefined" && this._stage) {
                    exprVal = this._stage.getModelValue(modelExpr);
                }
                if (typeof exprVal != "undefined") {
                    if (this._self) {
                        this._self.visible = (this._self.visible && exprVal);
                    }
                }
            }

            if (this._self) {
                this._self.id = this.id;
                this._self.type = this._type;
                this._self['z-index'] = data['z-index'];
            }

            // Render the plugin component
            if (this._render) {
                if (this._isContainer && this._type == 'stage') {
                    this.cache();
                }
                this.render();
            }
            // Draw border and shadow only if the object is visible
            if ((this._self) && (this._self.visible)) {
                // Draw border if needed
                this.drawBorder(data, dims);

                // Draw shadow if needed
                if (data.shadow) {
                    this.addShadow();
                }

                //this is to ratate the plugin with border
            }
            if (this._self) {
                this.rotation(data);
            }
        } catch (e) {
            var pluginName;
            if(!_.isUndefined(data)){
                pluginName = data.pluginType ? data.pluginType : "Custom";
            }
            EkstepRendererAPI.logErrorEvent(e, {'type':'plugin','objectType':data.pluginType,'action': data.event ? (data.event.action ? data.event.action.command : data.event.type) : 'transistion','objectId': data.id || data._id});
            showToaster('error', pluginName +':Plugin failed');
            console.warn('Plugin init is failed due to', e);
        }

    },
    handleFont: function(data) {
        if (data.font) {
            data.font = data.font.trim();
        }
        if (_.isEmpty(data.font) || (!_.isUndefined(data.font) && this._unSupportedFonts.indexOf(data.font.toLowerCase()) > -1)) {
            // This is fallback support for fonts & we are ignoring NotoSans, NotoSans Oriya, Verdana
            data.font = this.getDefaultFont();
        }
    },
    cache: function() {
        this._self.cache(this._dimensions.x, this._dimensions.y, this._dimensions.w, this._dimensions.h);
    },
    uncache: function() {
        this._self.uncache();
    },
    setIndex: function(idx) {
        this._index = idx;
    },
    setDimensions: function() {
        var dims = this.relativeDims();
        this._self.x = dims.x ? dims.x : 0;
        this._self.y = dims.y ? dims.y : 0;
        this._self.width = dims.w ? dims.w : 1; //default width = 1
        this._self.height = dims.h ? dims.h : 1; //default height = 1
    },

    /**
     * Adds a child to this plugin intance. This can be useful for composite scenarios.
     * @param pluginId {string} plugin id inside which child had to be added
     * @param child {object} child element which has to be added inside plugin
     * @memberof EkstepRenderer.Plugin
     */
    addChild: function(child, childPlugin) {
        var nextIdx = this._currIndex++;
        this._self.addChildAt(child, this._self.children.length);
        if (childPlugin) {
            childPlugin.setIndex(nextIdx);
            if (childPlugin._id) {
                this._childIds.push(childPlugin._id);
            }
        }
    },

    /**
     * Removes a child from this plugin by child index. Use this to dynamically manage composite children.
     * @param id {string} index of createjs element object
     * @memberof EkstepRenderer.Plugin
     */
    removeChildAt: function(idx) {
        this._self.removeChildAt(idx);
    },

    /**
     * Removes a child from this plugin by child instance. Use this to dynamically manage composite children.
     * @param child {object} createjs element to be removed
     * @memberof EkstepRenderer.Plugin
     */
    removeChild: function(child) {
        this._self.removeChild(child);
    },

    render: function() {
        if (this._self) {
            this._parent.addChild(this._self, this);
        } else {
            console.warn("Skipped rendering the plugin object: ", this._id);
        }
    },

    update: function() {
        this._theme.update();
    },

    /**
     * To get plugin dimensions specified in ECML/JSON
     * @memberof EkstepRenderer.Plugin
     */
    dimensions: function() {
        return this._dimensions;
    },

    /**
     * To get plugin dimensions relative to Canvas/device width & height also with respect to it's parents
     * @memberof EkstepRenderer.Plugin
     */
    relativeDims: function() {
        if (this._parent) {
            var parentDims = this._parent.dimensions();
            this._dimensions = {
                x: parseFloat(parentDims.w * (this._data.x || 0) / 100),
                y: parseFloat(parentDims.h * (this._data.y || 0) / 100),
                w: parseFloat(parentDims.w * (this._data.w || 0) / 100),
                h: parseFloat(parentDims.h * (this._data.h || 0) / 100),
                stretch: ((typeof(this._data.stretch) != "undefined") ? this._data.stretch : true)
            }
        }
        return this._dimensions;
    },
    getRelativeDims: function(data) {
        var parentDims = this._parent.dimensions();
        var relDimensions = {
            x: parseFloat(parentDims.w * (data.x || 0) / 100),
            y: parseFloat(parentDims.h * (data.y || 0) / 100),
            w: parseFloat(parentDims.w * (data.w || 0) / 100),
            h: parseFloat(parentDims.h * (data.h || 0) / 100),
            stretch: ((typeof(data.stretch) != "undefined") ? data.stretch : true)
        }
        return relDimensions;
    },
    setScale: function() {
        var sb = this._self.getBounds();
        var dims = this.relativeDims();
        var parentDims = this._parent.dimensions();

        // To maintain aspect ratio when both h and w are specified
        if (!dims.stretch) {
            if ((dims.h != 0) && (dims.w != 0)) {
                // If h > w, then constrain on w (equivalent to setting h = 0) and vice versa
                if (sb.height > sb.width) dims.h = 0;
                else dims.w = 0;
            }
        }

        // Compute constrained dimensions (e.g. if w is specified but not height)
        if (dims.h == 0) {
            dims.h = dims.w * sb.height / sb.width;
            if (parentDims.h < dims.h) {
                dims.h = parentDims.h;
                dims.w = dims.h * sb.width / sb.height;
            }
        }
        if (dims.w == 0) {
            dims.w = dims.h * sb.width / sb.height;
            if (parentDims.w < dims.w) {
                dims.w = parentDims.w;
                dims.h = dims.w * sb.height / sb.width;
            }
        }

        // Remember the computed dimensions
        this._dimensions.h = dims.h;
        this._dimensions.w = dims.w;

        // Scale the object based on above computations
        if (this._self) {
            this._self.scaleY = dims.h / sb.height;
            this._self.scaleX = dims.w / sb.width;
        }
    },
    initialize: function(data) {
        //console.info("Base plugin intialization..");
    },
    /**
     * Initializes the plugin by reading from ECML.
     * @private
     * @memberof EkstepRenderer.Plugin
     */
    initPlugin: function(data) {
        PluginManager.addError('Subclasses of plugin should implement this function');
        throw "Subclasses of plugin should implement this function";
    },
    play: function() {
        PluginManager.addError('Subclasses of plugin should implement play()');
    },
    pause: function() {
        PluginManager.addError('Subclasses of plugin should implement pause()');
    },
    stop: function() {
        PluginManager.addError('Subclasses of plugin should implement stop()');
    },
    togglePlay: function() {
        PluginManager.addError('Subclasses of plugin should implement togglePlay()');
    },
    refresh: function() {
        PluginManager.addError('Subclasses of plugin should implement refresh()');
    },

    /**
     * property of the plugin to show it's visiblity on stage
     * @param action {object} action command to show createjs element
     * @memberof EkstepRenderer.Plugin
     * @property show
     */
    show: function(action) {
        if (_.contains(this.events, 'show')) {
            EventManager.dispatchEvent(this._data.id, 'show');
        } else if (!this._self.visible) {
            this._self.visible = true;
            EventManager.processAppTelemetry(action, 'SHOW', this);
        }
        Renderer.update = true;
    },

    /**
     * Property of the plugin to hide it's visiblity on stage
     * @param action {object} action command to hide createjs element
     * @memberof EkstepRenderer.Plugin
     * @property hide
     */
    hide: function(action) {
        if (_.contains(this.events, 'hide')) {
            EventManager.dispatchEvent(this._data.id, 'hide');
        } else if (this._self && this._self.visible) {
            this._self.visible = false;
            EventManager.processAppTelemetry(action, 'HIDE', this);
        }
        Renderer.update = true;
    },

    /**
     * property of the plugin to toggle it's visiblity on stage
     * @param action {object} action command to toggle show/hide of createjs element
     * @memberof EkstepRenderer.Plugin
     * @property toggleShow
     */
    toggleShow: function(action) {
        if (_.contains(this.events, 'toggleShow')) {
            EventManager.dispatchEvent(this._data.id, 'toggleShow');
        } else {
            this._self.visible = !this._self.visible;
            EventManager.processAppTelemetry(action, this._self.visible ? 'SHOW' : 'HIDE', this);
        }
        Renderer.update = true;
    },

    /**
     * property of the plugin to toggle it's shadow
     * @param action {object} action command to toggle Shadow of createjs element(optional)
     * @memberof EkstepRenderer.Plugin
     * @property toggleShadow
     */
    toggleShadow: function(action) {
        var isVisible = false;

        if (this.hasShadow()) {
            this.removeShadow();
            isVisible = false;
        } else {
            this.addShadow();
            isVisible = true;
        }
        Renderer.update = true;
        return isVisible;
    },

    /**
     * property of the plugin to add shadow using createJS shadow property
     * @memberof EkstepRenderer.Plugin
     * @property addShadow
     */
    addShadow: function() {
        var shadowObj = this._self.shadow;

        // If the shadow is a plugin, set the visibility to true
        if ((shadowObj) && (shadowObj._self) && ('visible' in shadowObj._self)) {
            shadowObj._self.visible = true;
        } else {
            // Not a plugin, render a normal shadow
            var shadowColor = this._data.shadowColor || '#cccccc';
            shadowColor = this._data.shadow || shadowColor;
            var offsetX = this._data.offsetX || 0;
            var offsetY = this._data.offsetY || 0;
            var blur = this._data.blur || 5;
            this._self.shadow = new createjs.Shadow(shadowColor, offsetX, offsetY, blur);
        }
    },

    /**
     * property of the plugin to remove it's shadow
     * @memberof EkstepRenderer.Plugin
     * @property removeShadow
     */
    removeShadow: function() {
        var shadowObj = this._self.shadow;

        // If the shadow is a plugin, set the visibility to false
        if ((shadowObj) && (shadowObj._self) && ('visible' in shadowObj._self)) {
            shadowObj._self.visible = false;
        } else {
            // Not a plugin (normal shadow), unset the object
            this._self.shadow = undefined;
        }
    },

    /**
     * Returns the boolean which show if element has shawdow or not.
     * @memberof EkstepRenderer.Plugin
     */
    hasShadow: function() {
        var visibleShadow = false;
        var shadowObj = this._self.shadow;

        // If the shadow is a plugin, then check the visible property
        if ((shadowObj) && (shadowObj._self) && ('visible' in shadowObj._self)) {
            visibleShadow = shadowObj._self.visible;
        } else {
            // It is not a plugin, check if the shadow object is created
            if (this._self.shadow) {
                visibleShadow = true;
            }
        }

        return visibleShadow;
    },

    /**
     * Draw a border on element
     * @param data {object} element outside which border should be drawed
     * @param dims {object} dimension of border to be drawed
     * @memberof EkstepRenderer.Plugin
     */
    drawBorder: function(data, dims) {
        if (data.stroke) {
            var strokeWidth = (data['stroke-width'] || 1);
            //var borderShape;
            var graphics = this._self.graphics;
            if (!this._self.graphics) {
                this.borderShape = new createjs.Shape();
                this.borderShape.x = this._self.x;
                this.borderShape.y = this._self.y;
                graphics = this.borderShape.graphics;
            }
            graphics.beginStroke(data.stroke);
            this.borderShape.alpha = (data['stroke-opacity'] || 1);
            graphics.setStrokeStyle(strokeWidth);
            // graphics.setStrokeDash([10,10],0);


            // dims.x += strokeWidth/2;
            // dims.y += strokeWidth/2;
            // // dims.w += strokeWidth/2;
            // // dims.h += strokeWidth/2;
            // this._self.x += strokeWidth;
            // this._self.y += strokeWidth;

            graphics.dr(0, 0, dims.w, dims.h);
            //graphics.dr(dims.x + strokeWidth/2, dims.y + strokeWidth/2, dims.w - strokeWidth, dims.h - strokeWidth);
            if (!this._self.graphics) {
                this._parent.addChild(this.borderShape);
            }
            Renderer.update = true;
        }
    },

    /**
     * Rotate an element
     * @param data {object} plugin object
     * @memberof EkstepRenderer.Plugin
     */
    rotation: function(data) {
        var degreeRotation = 0;
        if (data.rotate) {
            degreeRotation = data.rotate;
        } else if (_.isNumber(data)) {
            degreeRotation = data;
        }
        if (!_.isUndefined(this.borderShape)) {
            this.borderShape.rotation = degreeRotation;
        }
        this._self.rotation = degreeRotation;
    },

    enableDrag: function(asset, snapTo) {
        asset.cursor = "pointer";
        asset.on("mousedown", function(evt) {
            this.parent.addChild(this);
            this.offset = {
                x: this.x - evt.stageX,
                y: this.y - evt.stageY
            };
        });
        asset.on("pressmove", function(evt) {
            this.x = evt.stageX + this.offset.x;
            this.y = evt.stageY + this.offset.y;
            Renderer.update = true;
        });
        if (snapTo) {
            asset.on("pressup", function(evt) {
                var plugin = PluginManager.getPluginObject(snapTo);
                var dims = plugin._dimensions;
                var xFactor = parseFloat(this.width * (50 / 100));
                var yFactor = parseFloat(this.height * (50 / 100));
                var x = dims.x - xFactor,
                    y = dims.y - yFactor,
                    maxX = dims.x + dims.w + xFactor,
                    maxY = dims.y + dims.h + yFactor;
                var snapSuccess = false;
                if (this.x >= x && (this.x + this.width) <= maxX) {
                    if (this.y >= y && (this.y + this.height) <= maxY) {
                        snapSuccess = true;
                    }
                }
                if (!snapSuccess) {
                    this.x = this.origX;
                    this.y = this.origY;
                } else {
                    if (plugin._data.snapX) {
                        this.x = dims.x + (dims.w * plugin._data.snapX / 100);
                    }
                    if (plugin._data.snapY) {
                        this.y = dims.y + (dims.h * plugin._data.snapY / 100);
                    }
                }
                Renderer.update = true;
            });
        }
    },
    evaluateExpr: function(expr) {
        if (!expr) return "";
        var app = GlobalContext._params;
        var stage = {};
        if (this._stage) {
            stage = this._stage.params;
        } else if (this._type == 'stage') {
            stage = this.params;
        }
        var content = {};
        if (this._theme) {
            content = this._theme._contentParams;
        }
        var value = undefined;
        try {
            expr = expr.trim();
            if ((expr.substring(0, 2) == "${") && (expr.substring(expr.length - 1, expr.length) == "}")) {
                expr = expr.substring(2, expr.length);
                expr = expr.substring(0, expr.length - 1);
                value = eval(expr);
            } else {
                value = eval(expr);
            }
        } catch (err) {
            console.warn('expr: ' + expr + ' evaluation faild:', err.message);
        }
        return value;
    },
    replaceExpressions: function(model) {
        var arr = [];
        var idx = 0;
        var nextIdx = model.indexOf('${', idx);
        var endIdx = model.indexOf('}', idx + 1);
        while (nextIdx != -1 && endIdx != -1) {
            var expr = model.substring(nextIdx, endIdx + 1);
            arr.push(expr);
            idx = endIdx;
            nextIdx = model.indexOf('${', idx);
            endIdx = model.indexOf('}', idx + 1);
        }
        if (arr.length > 0) {
            for (var i = 0; i < arr.length; i++) {
                var val = this.evaluateExpr(arr[i]);
                model = model.replace(arr[i], val);
            }
        }
        return model;
    },
    getParam: function(param) {
        var value;
        var tokens = param.split('.');
        if (tokens.length >= 2) {
            var scope = tokens[0];
            var idx = param.indexOf('.');
            var paramName = param.substring(idx + 1);
            if (scope && scope.toLowerCase() == 'app') {
                value = GlobalContext.getParam(paramName);
            } else if (scope && scope.toLowerCase() == 'stage') {
                value = this._stage.getParam(paramName);
            } else {
                value = this._theme.getParam(paramName);
            }
        } else if (this._stage) {
            value = this._stage.getParam(param);
        }
        return value;
    },
    getDefaultFont: function() {
        this._defaultFont = 'NotoSans, NotoSansGujarati, NotoSansOriya, NotoSansMalayalam';
        return this._defaultFont;
    },
    transitionTo: function() {
        PluginManager.addError('Subclasses of plugin should implement transitionTo()');
    },
    evaluate: function() {
        PluginManager.addError('Subclasses of plugin should implement evaluate()');
    },
    reload: function() {
        PluginManager.addError('Subclasses of plugin should implement reload()');
    },
    restart: function() {
        PluginManager.addError('Subclasses of plugin should implement reload()');
    },

    /**
     * Blur the current element
     * @memberof EkstepRenderer.Plugin
     */
    blur: function(action) {
        var instance = this;
        var obj = instance._self;
        var blurFilter = new createjs.BlurFilter(25, 25, 1);
        obj.filters = [blurFilter];
        var bounds = instance.relativeDims();
        obj.cache(bounds.x, bounds.y, bounds.w, bounds.h);
        Renderer.update = true;
    },

    /**
     * Unblur the current element
     * @memberof EkstepRenderer.Plugin
     */
    unblur: function(action) {
        var instance = this;
        instance._self.filters = [];
        instance._self.uncache();
        Renderer.update = true;
    },

    /**
     * Invoke childrens again to reflect changes
     * @param data {object} Data which need to be updated
     * @param parent {object} parent of data element
     * @param stage {object} Stage inside which element resides
     * @param theme {object} Theme object
     * @memberof EkstepRenderer.Plugin
     */
    invokeChildren: function(data, parent, stage, theme) {
        var children = [];
        for (k in data) {
            if (PluginManager.isPlugin(k)) {
                if (_.isArray(data[k])) {
                    _.each(data[k], function(item) {
                        item.pluginType = k;
                        if (!item['z-index']) item['z-index'] = -1;
                        children.push(item);
                    });
                } else {
                    data[k].pluginType = k;
                    if (!data[k]['z-index']) data[k]['z-index'] = -1;
                    children.push(data[k]);
                }
            }
        }
        //children = _.sortBy(children, 'z-index'); // Now this is no longer required as the elements are sorted by z-index at the end
        for (k in children) {
            var item = children[k];
            if(item.pluginType) PluginManager.invoke(item.pluginType, item, parent, stage, theme);
        }
        if (parent._self) {
            parent._self.sortChildren(function(obj1, obj2, options) {
                if (_.isUndefined(obj2['z-index'])) obj2['z-index'] = -1;
                if (_.isUndefined(obj1['z-index'])) obj1['z-index'] = -1;
                if (obj1['z-index'] > obj2['z-index']) {
                    return 1;
                }
                if (obj1['z-index'] < obj2['z-index']) {
                    return -1;
                }
                return 0;
            });
        }
    },
    getPluginParam: function(param) {
        var instance = this;
        var params = instance._pluginParams;
        var expr = 'params.' + param;
        return eval(expr);
    },
    setPluginParam: function(param, value, incr, max) {
        var instance = this;
        var fval = instance._pluginParams[param];
        if (incr) {
            if (!fval)
                fval = 0;
            fval = (fval + incr);
        } else {
            fval = value;
        }
        if (0 > fval) fval = 0;
        if ("undefined" != typeof max && fval >= max) fval = 0;
        instance._pluginParams[param] = fval;
    },
    destroy: function() {
        var pluginName = this._type;
        delete org.ekstep.pluginframework.pluginManager.plugins[pluginName];
        console.log(pluginName, " Plugin instance got destroyed");
    },
    setPluginParamValue: function(action) {
        var scope = action.scope;
        var param = action.param;
        var paramExpr = action['ev-value'];
        var paramModel = action['ev-model'];
        var val;
        if (paramExpr) {
            val = this.getPluginParam(paramExpr);
        } else if (paramModel) {
            if (this._stage) {
                var model = this.replaceExpressions(paramModel);
                val = this._stage.getModelValue(model);
            }
        } else {
            val = action['param-value'];
        }
        var incr = action['param-incr'];
        if (scope && scope.toLowerCase() == 'app') {
            GlobalContext.setParam(param, val, incr);
        } else if (scope && scope.toLowerCase() == 'stage') {
            this._stage.setParam(param, val, incr);
        } else if (scope && scope.toLowerCase() == 'content') {
            this._theme.setParam(param, val, incr);
        } else {
            this.setPluginParam(param, val, incr);
        }
    },

    /**
     * Return all children of data
     * @param data {object}
     * @memberof EkstepRenderer.Plugin
     */
    getInnerECML: function(data) {
        var children = {};
        data = ("undefined" == typeof data) ? this._data : data;
        for (k in data) {
            if (PluginManager.isPlugin(k) && _.isObject(data[k]) && !_.isEmpty(data[k])) {
                children[k] = data[k];
            }
        }
        return children;
    },

    /**
     * It takes the value and the param to set its state
     * @param param {string} Param is a string defining the type of question (mcq/mtf/ftb)
     * @param value {object/array} value for mcq and mtf type is an array and for ftb type is an object
     * @param isStateChanged {boolean} state true or false if pluginState is changed
     * @memberof EkstepRenderer.Plugin
     */
    setState: function(param, value, isStateChanged) {
        if (!_.isUndefined(isStateChanged)) {
            this._stage.isStageStateChanged(isStateChanged);
        }
        this._stage.setParam(param.toLowerCase(), value);
    },

    /**
     * Returns state of the param.
     * Undefined if the param is not present is the currentState.
     * @param paramName {string} name of the param.
     * @memberof EkstepRenderer.Plugin
     */
    getState: function(param) {
        if (!_.isUndefined(this._stage._currentState)) {
            return this._stage._currentState[param];
        }
    },

});

/**
 * @author Manjunath Davanam <manjunathd@ilimi.in>
 */
var renderer_services = function() {};
window.org.ekstep.service = new renderer_services();
renderer_services = undefined;

org.ekstep.service.mainService = Class.extend({
    getAPISlug: function() {
        var globalConfig = EkstepRendererAPI.getGlobalConfig();
        return globalConfig.apislug;
    },
    init: function(config) {
        this.initService(config);
    },
    initService: function(config) {},
    initialize: function(){
    }
});
org.ekstep.service.init = function() {
    if (typeof cordova !== 'undefined') {
        org.ekstep.service.renderer = genieservice;
    }
};

/*TODO: Telemetry_web should be part of telemetryservice*/
telemetry_web = {
    tList: [],
    send: function(string) {
      console.log("Telemetry Event:", string);
        // EventBus.dispatch("telemetryEvent",string);
        return new Promise(function(resolve, reject) {
            telemetry_web.tList.push(string);
            resolve(true);
        });
    }
};
if ("undefined" == typeof cordova) telemetry = telemetry_web;

org.ekstep.service.web = new(org.ekstep.service.mainService.extend({
    init: function() {
    },
    initialize: function() {
    },
    api: {
        _baseUrl: undefined,
        contentBasePath: '/content/v3/read/',
        languageBasePath: '/language/v3/',
        telemetryBasePath: '/data/v3/telemetry',
        getAPI: function() {
            return this._baseUrl + this.contentBasePath;
        },
        getLanguageAPI: function() {
            return this._baseUrl + this.languageBasePath;
        },
        getTelematyAPI: function() {
            return this._baseUrl + this.telemetryBasePath;
        },
        setBaseUrl: function(baseUrl) {
            this._baseUrl = baseUrl;
        },
        getBaseUrl: function() {
            if (_.isUndefined(this._baseUrl)) {
                console.log("Base path is undefined.");
                return;
            }
            return this._baseUrl;
        }
    },
    callApi: function(url, type, headersParam, data, cb) {
        headersParam["Content-Type"] = "application/json";
        jQuery.ajax({
            url: url,
            type: type,
            headers: headersParam,
            data: data
        }).done(function(resp) {
            cb(resp)
        });
    },
    getCurrentUser: function() {
        return new Promise(function(resolve, reject) {
            $.getJSON("assets/user_list/user_list.json", function(data) {
                resolve(data[0]);
            })
        });
    },

    getAllUserProfile: function() {
        return new Promise(function(resolve, reject) {
            $.getJSON("assets/user_list/user_list.json", function(data) {
                resolve(data);
            })
        });
    },

    setUser: function(uid) {
        return new Promise(function(resolve, reject) {
            resolve(true);
        });
    },

    getMetaData: function() {
        return new Promise(function(resolve, reject) {
            var result = {};
            result = {
                "flavor": "sandbox",
                "version": "1.0.1"
            };
            resolve(result);
        });
    },
    getContentBody: function(id, headersParam) {
        var instance = this;
        return new Promise(function(resolve, reject) {
            instance.callApi(org.ekstep.service.web.api.getAPI() + id + "?fields=body", 'GET', headersParam, undefined, function(resp) {
                var result = {};
                if (!resp.error) {
                    result.list = resp;
                    resolve(resp.result.content);
                } else {
                    console.info("err : ", resp.error)
                }
            });
        });
    },
    getContent: function(id) {
        return new Promise(function(resolve, reject) {
            if (!(typeof content == 'undefined')) {
                if ("application/vnd.ekstep.content-collection" == content.metadata.mimeType) {
                    resolve(genieservice.getContentMetadata(id));
                } else {
                    resolve(content.metadata);
                }
            } else {
                resolve(genieservice.getContentMetadata(id));
            }
        });
    },
    getContentMetadata: function(id, headersParam) {
        var instance = this;
        return new Promise(function(resolve, reject) {
            instance.callApi(org.ekstep.service.web.api.getAPI() + id, 'GET', headersParam, undefined, function(resp) {
                var result = {};
                if (!resp.error) {
                    result.list = resp;
                    var metadata = resp.result.content;
                    var map = {};
                    map.identifier = metadata.identifier;
                    map.localData = metadata;
                    map.mimeType = metadata.mimeType;
                    map.isAvailable = true;
                    map.path = "stories/" + metadata.code;
                    resolve(map);
                } else {
                    console.info("err : ", resp.error)
                }
            });
        });
    },
    languageSearch: function(filter) {
        var instance = this;
        return new Promise(function(resolve, reject) {
            var headersParam = {};
            instance.callApi(org.ekstep.service.web.api.getLanguageAPI() + "search", 'POST', headersParam, filter, function(resp) {
                var result = {};
                if (!resp.error) {
                    result.list = resp;
                    resolve(resp.result);
                } else {
                    console.info("err : ", resp.error)
                }
            });
        });
    },
    sendTelemetry: function(data, headersParam) {
        var instance = this;
        return new Promise(function(resolve, reject) {
            headersParam['dataType'] = 'json';
            instance.callApi(org.ekstep.service.web.api.getTelematyAPI(), 'POST', headersParam, JSON.stringify(data), function(resp) {
                var result = {};
                if (!resp.error) {
                    result.data = resp;
                    resolve(resp.result);
                } else {
                    console.info("err : ", resp.error)
                }
            });
        });
    },
    endContent: function() {
        // On close of the content call this function
        var contentId = localStorage.getItem('cotentId');
        if (_.isUndefined(contentId)) {
            console.log("ContentId is not defined in URL.");
            return;
        }
        var endPageStateUrl = '#/content/end/' + contentId;
        this.showPage(endPageStateUrl);
    },
    showPage: function(pageUrl) {
        if ("undefined" != typeof cordova) {
            var url = "file:///android_asset/www/index.html" + pageUrl;
            window.location.href = url;
        } else if (self != top) {
            // if the it is Iframe then fallow the below url syntax
            /*https://dev.ekstep.in/assets/public/preview/dev/preview.html?webview=true#/content/end/do_10097197"*/
            var iframe_url = window.frameElement.src;
            iframe_url = iframe_url.indexOf("&") != -1 ? iframe_url.substring(0, iframe_url.indexOf("&")) : iframe_url;
            window.location = iframe_url + pageUrl;
        } else {
            window.location = "/" + pageUrl;
        }
    }
}));
org.ekstep.service.renderer = org.ekstep.service.web;

org.ekstep.service.content = new(org.ekstep.service.mainService.extend({
    init: function() {
    },
    getContentList: function(filter, childrenIds) {
        return new Promise(function(resolve, reject) {
            org.ekstep.service.content._filterContentList(filter, childrenIds)
                .then(function(result) {
                    resolve(org.ekstep.service.content._getAvailableContentList(result));
                })
                .catch(function(err) {
                    console.log(AppErrors.contentListFetch, err);
                    reject(err);
                });
        });
    },
    getContent: function(id) {
        return new Promise(function(resolve, reject) {
            org.ekstep.service.renderer.getContent(id)
                .then(function(resp) {
                    var item = resp;

                    // New genie resp object having diffrent fields. Hence we are assigning new feilds to old fields
                    if (item.contentData) item.localData = item.contentData;
                    if (item.isAvailableLocally) item.isAvailable = item.isAvailableLocally;

                    if (item.isAvailable) {
                        resolve(org.ekstep.service.content._prepareContent(item));
                    } else {
                        reject("Content is not available.");
                    }
                })
                .catch(function(err) {
                    console.error(AppErrors.contetnPathFetch, err);
                    reject(err);
                });
        });
    },
    getContentAvailability: function(id) {
        return new Promise(function(resolve, reject) {
            org.ekstep.service.renderer.getContent(id)
                .then(function(contentData) {
                    if (!_.isUndefined(contentData)) {
                        contentData.isAvailable = contentData.isAvailableLocally;
                        resolve(contentData.isAvailable);
                    } else {
                        console.error("Content is not available.");
                        reject("Content is not available.");
                    }
                })
                .catch(function(err) {
                    console.error(AppErrors.contetnPathFetch, err);
                    reject(err);
                });
        });
    },
    getRelatedContent: function(list, contentId, uid) {
        return new Promise(function(resolve, reject) {
            org.ekstep.service.renderer.getRelatedContent(list, contentId, uid)
                .then(function(item) {
                    if (item) {
                        resolve(item);
                    } else {
                        reject("Content is not available.");
                    }
                })
                .catch(function(err) {
                    console.error(AppErrors.contetnPathFetch, err);
                    reject(err);
                });
        });
    },
    // Get the Total Assessment score of particular user of particular content.
    getLearnerAssessment: function(uid, id, contentExtras) {
        return new Promise(function(resolve, reject) {
            org.ekstep.service.renderer.getLearnerAssessment(uid, id, contentExtras)
                .then(function(score) {
                    if (score)
                        resolve(score);
                    else
                        reject("Score is not available.")
                });
        });
    },
    getContentBody: function(id, urlParams) {
        return new Promise(function(resolve, reject) {
            org.ekstep.service.renderer.getContentBody(id, urlParams)
                .then(function(body) {
                    resolve(body);
                })
                .catch(function(err) {
                    console.error(AppErrors.contetnPathFetch, err);
                    reject(err);
                });
        });
    },
    getContentMetadata: function(id, urlParams) {
        return new Promise(function(resolve, reject) {
            org.ekstep.service.renderer.getContentMetadata(id, urlParams)
                .then(function(metadata) {
                    resolve(metadata);
                })
                .catch(function(err) {
                    console.error(AppErrors.contetnPathFetch, err);
                    reject(err);
                });
        });
    },
    _prepareContent: function(item) {
        var data = item.localData || item.serverData || item.contentData;
        if (_.isUndefined(item.path)) {
            item.path = item.basePath;
        }

        if (item.path && data) {
            var path = (item.path.charAt(item.path.length - 1) == '/') ? item.path.substring(0, item.path.length - 1) : item.path;
            path = (window.cordova) ? "file://" + path : path;
            data.baseDir = path;
            if ("undefined" != typeof cordova)
                data.appIcon = (data.appIcon) ? path + "/" + data.appIcon : path + "/logo.png";
            else
                data.appIcon = (isbrowserpreview) ? data.appIcon : path + "/logo.png";
            data.mimeType = item.mimeType;
            data.status = "ready";
            data.isAvailable = item.isAvailable;
        } else {
            if (!data) data = {};
            data.status = "error";
            console.info("Path is not available for content:", item);
        }
        return data;
    },
    _filterContentList: function(filter, childrenIds) {
        return new Promise(function(resolve, reject) {
            var list = [];
            var returnResult = function(list, errorMessage) {
                if (errorMessage) console.error(errorMessage);
                resolve(list);
            };
            if (filter || childrenIds) {
                new Promise(function(resolve, reject) {
                        var promises = [];
                        if (childrenIds && childrenIds.length > 0) {
                            _.each(childrenIds, function(childId) {
                                promises.push(function(callback) {
                                    org.ekstep.service.renderer.getContent(childId)
                                        .then(function(item) {
                                            callback(null, item);
                                        })
                                        .catch(function(err) {
                                            callback(null, err);
                                        });
                                });
                            });
                            async.parallel(promises, function(err, resList) {
                                list = resList;
                                resolve(list);
                            });
                        } else {
                            resolve(list);
                        }
                    })
                    .then(function() {
                        if (filter) {
                            org.ekstep.service.renderer.getContentList(filter)
                                .then(function(result) {
                                    list = _.union(list, result.list);
                                    returnResult(list);
                                })
                                .catch(function(err) {
                                    returnResult(list, "Error while fetching filtered content:" + JSON.stringify(err));
                                });
                        } else {
                            returnResult(list);
                        }
                    })
                    .catch(function(err) {
                        returnResult(list, "Error while fetching filterContentList:" + JSON.stringify(err));
                    })
            } else {
                if ("undefined" != typeof cordova) {
                    returnResult(list, "Error while fetching filtered content: Empty Collection");
                } else {
                    org.ekstep.service.renderer.getContentList([])
                        .then(function(result) {
                            returnResult(result.list);
                        })
                        .catch(function(err) {
                            returnResult(list, "Error while fetching filterContentList:" + JSON.stringify(err));
                        });
                }
            }
        });
    },
    _getAvailableContentList: function(list) {
        var globalConfig = EkstepRendererAPI.getGlobalConfig();
        list = _.filter(list, function(item) {
            return item.isAvailable && _.indexOf(globalConfig.mimetypes, item.mimeType) > -1;
        });
        list = _.map(list, function(item) {
            return org.ekstep.service.content._prepareContent(item);
        });
        list = _.filter(list, function(data) {
            return data.status == "ready";
        });
        return list;
    },
    getAllUserProfile: function() {
        return new Promise(function(resolve, reject) {
            org.ekstep.service.renderer.getAllUserProfile()
                .then(function(data) {
                    resolve(data);
                })
                .catch(function(err) {
                    console.error(AppErrors.contetnPathFetch, err);
                    reject(err);
                });
        });
    },
    getUser: function(uid) {

    },
    getCurrentUser: function() {
        return new Promise(function(resolve, reject) {
            org.ekstep.service.renderer.getCurrentUser().then(function(data) {
                resolve(data);
            }).catch(function(err) {
                console.error(AppErrors.contetnPathFetch, err);
                reject(err);
            });
        });
    },
    setUser: function(uid) {
        return new Promise(function(resolve, reject) {
            org.ekstep.service.renderer.setUser(uid).then(function(data) {
                resolve(data);
            }).catch(function(err) {
                console.error(AppErrors.contetnPathFetch, err);
                reject(err);
            });
        });
    }

}));

/**
 * The EkStep Renderer API is the core interface of the plugins with the rest of the render framework. It allows the plugins
 * to access the framework resources, launch popups, and handle events raised by the framework. Plugins should not call any
 * other framework classes directly.
 *
 * @class EkstepRendererAPI
 * @author Vinu Kumar <vinu.kumat@tarento.com>
 */
window.EkstepRendererAPI = {
    baseURL: "",
    /**
     * Register an event listener callback function for the events raised by the framework.
     * @param type {string} name of the event (e.g. actionNavigateSkip).
     * @param callback {function} callback function
     * @param scope {object} the scope of the callback (use this)
     * @memberof EkstepRendererAPI
     */
    addEventListener: function(type, callback, scope) {
        EventBus.addEventListener(type, callback, scope);
    },
    /**
     * Fires an event to the framework, allowing other plugins who may have registered to receive the callback notification. All
     * communication between the framework and other plugins is via the events.
     * @param type {string} name of the event to fire (e.g. actionNavigateSkip)
     * @param data {object} event data to carry along with the notification
     * @param target {object} the scope of the event (use this)
     * @memberof EkstepRendererAPI
     */
    dispatchEvent: function(type, data, target) {
        EventBus.dispatch(type, data, target);
    },

    /**
     * Returns all event which are being registed on element.
     * empty if the none of the events are being registed.
     * @memberof EkstepRendererAPI
     */
    getEvents: function() {
        return EventBus.getEvents();
    },

    /**
     * @param type {string} name of the event which is being registred
     * Returns paticular event which are being registed on element.
     * empty if the event not registed.
     * @memberof EkstepRendererAPI
     */
    hasEventListener: function(eventName, callback, scope) {
        return EventBus.hasEventListener(eventName, callback, scope)
    },

    /**
     * Remove an event listener to an event. Plugins should cleanup when they are removed.
     * @param type {string} name of the event registered with (e.g. actionNavigateSkip)
     * @param callback {function} remove the callback function
     * @param scope {object} the scope of the event (use this)
     * @memberof EkstepRendererAPI
     */
    removeEventListener: function(type, callback, scope) {
        EventBus.removeEventListener(type, callback, scope)
    },

    /**
     * Notifies to framework to update the canvas objects. This can be done by the plugin when
     * plugin wants to update OR render the object to canvas.
     * @memberof EkstepRendererAPI
     */
    render: function() {
        Renderer.update = true;
    },

    /**
     * Returns the current content manifest data which.
     * @memberof EkstepRendererAPI
     */
    getManifest: function() {
        return Renderer.theme._data.manifest;
    },

    /**
     * Removes current stage HTML elements. This could be useful when plugins work across stages
     * Using this, a plugin can get access to remove the current stage HTML element such vidoe html element etc.,
     * @memberof EkstepRendererAPI
     */
    removeHtmlElements: function() {
        Renderer.theme.removeHtmlElements();
    },

    /**
     * Refresh the rendering of current stage - plugins can request the stages to be refresh if any change
     * has been made.
     * @memberof EkstepRendererAPI
     */
    refreshStage: function() {
        EventBus.dispatch('actionReload');
    },

    /**
     * Returns all stages in the current content. This could be useful when plugins work across stages
     * such as timers that work across stages or page number plugins. Using this, a plugin can get access to all
     * stages, and instantiate plugins on each stage.
     * @memberof EkstepRendererAPI
     */
    getAllStages: function() {
        return Renderer.theme._data.stage;
    },

    /**
     * Returns current stage data in the content. This could be useful when plugins work across stages
     * such as timers that work across stages or page number plugins. Using this a plugin can get access to
     * current stage. undefined if the currentStage is not loaded or present.
     * @memberof EkstepRendererAPI
     */
    getCurrentStage: function() {
        return Renderer.theme._currentScene;
    },

    /**
     * Returns current stage Id of the content. This could be useful when plugins can get access to
     * current stage identifier.undefined if the currentstage identifier is not present.
     * @memberof EkstepRendererAPI
     */
    getCurrentStageId: function() {
        return (!_.isUndefined(Renderer)) ? Renderer.theme._currentStage : '';
    },

    /**
     * Returns the HTML5 canvas for rendering plugins. By default, the rederer uses create.js and recommends the plugins to also use CreateJS. This helps in getting WYSIWYG on renderer canvas(CreateJS) & editor canvas(FabricJS).  However, this method provides access to the underlying native HTML5 canvas if needed. For example, if your plugin uses some other third-party graphics library for rendering.
     * @memberof EkstepRendererAPI
     */
    getCanvas: function() {
        return document.getElementById('gameCanvas');
    },

    /**
     * Returns the baseURL of asset.
     * Object to hold Base URL
     * @member {String} baseURL
     * @memberof EkstepRendererAPI
     */
    getBaseURL: function() {
        return Renderer.theme._basePath;
    },

    /**
     * Returns the complete current content data object(JSON object of Theme/ECML/Content). This is usefull for the plugins developer to know about no. of stages, stage elements, stage assets/media etc..
     * current content data object
     * @memberof EkstepRendererAPI
     */
    getContentData: function() {
        return Renderer.theme._data;
    },


    /**
     * Returns a plugin instance for the given plugin Id once the plugin registarion/invoke is done. Plugins can use this work with dependencies
     * or build plugins that enhance the behavior of other plugins.
     * @memberof EkstepRendererAPI
     */
    getPluginInstance: function(pluginId) {
        if(typeof PluginManager !='undefined'){
            return PluginManager.getPluginObject(pluginId);
        }
    },

    /**
     * Returns a plugin instance for the given plugin Id once the plugin registarion/invoke is done. Plugins can use this work with dependencies
     * or build plugins that enhance the behavior of other plugins.
     * @memberof EkstepRendererAPI
     */
    getPluginObjs: function(pluginId) {
        return org.ekstep.pluginframework.pluginManager.pluginObjs[pluginId];
        // return PluginManager.getPluginObject(pluginId);
    },

    /**
     * Clear the current stage rendered objects, Plugins can get access to
     * current stage canvas object and plugin can clean all current stage rendrered object
     * @memberof EkstepRendererAPI
     */
    cleanRenderer: function() {
        Renderer.cleanUp();
    },

    /**
     * It will map controller object, This could be useful when plugins can get access to
     * map the controller.
     * @param controller {object} controller is object. It should have id, name, type and __cdata.
     * type defines controller type e.g(item, data), name defines controller name, id defines controller identifier
     * @memberof EkstepRendererAPI
     */
    addController: function(controller) {
        Renderer.theme.addController(controller)
    },

    /**
     * Returns the controller instance based on controller type and identifier.
     * this could be usefull when plugin get access to get the controller from canvas.
     * suppose if it returns undefined then Controller has not been registed.
     * @param cId {string} Controller identifier.
     * @param cType {string} Controller Type (e.g cType = data OR Items)
     @memberof EkstepRendererAPI
     */
    getController: function(cType, cId) {
        var c = cType + '.' + cId;
        return ControllerManager.getControllerInstance(c);
    },

    /**
     * Returns the currentStage controller instance.
     * undefined if the currentstage controller has not been registred.
     * @memberof EkstepRendererAPI
     */
    getCurrentController: function() {
        var currentStage = EkstepRendererAPI.getCurrentStage();
        if (currentStage) {
            return currentStage._stageController;
        }
    },

    /**
     * set the param to scope level.
     * @param scope {string} name of the scope (e.g. stage, theme, app)
     * @paramName {string} name to param to set.
     * @paramName {object} value of the param.
     * @memberof EkstepRendererAPI
     */
    setParam: function(scope, paramName, value) {
        if (scope === 'theme') {
            Renderer.theme.setParam(paramName, value);
        }
        if (scope === 'stage') {
            var currentStage = EkstepRendererAPI.getCurrentStage();
            if (currentStage) {
                currentStage.setParam(paramName, value);
            }
        }
        if (scope === 'app') {
            GlobalContext.setParam(paramName, value);
        }
    },

    /**
     * return the param data
     * @paramName {string} name to param to set.
     * @memberof EkstepRendererAPI
     */
    getStageParam: function(paramName) {
        var currentStage = EkstepRendererAPI.getCurrentStage();
        var paramData;
        if (paramName && currentStage) {
            paramData = currentStage.getParam(paramName);
        } else if (currentStage) {
            paramData = currentStage.params
        }
        return paramData;
    },

    /**
     * Returns the param value based on scope and paramName.
     * empty if the paramValue is not present in the scope.
     * @param scope {string} name of the scope (e.g. stage,theme,app)
     * @paramName {string} name to get from the particular scope.
     * @memberof EkstepRendererAPI
     */
    getParam: function(scope, paramName) {
        var paramData = '';
        if (scope === 'theme') {
            paramData = Renderer.theme.getParam(paramName);
        }
        if (scope === 'stage') {
            paramData = EkstepRendererAPI.getStageParam(paramName);
        }
        if (scope === 'app') {
            paramData = GlobalContext.getParam(paramName);
        }
        return paramData;
    },

    /**
     * Returns boolean value if current stage contain any assesment or not.
     * empty if the stage doesn't have any assesment.
     * @memberof EkstepRendererAPI
     */
    isItemScene: function() {
        var stage = EkstepRendererAPI.getCurrentStage();
        return stage.isItemScene();
    },

    /**
     * Returns the param value based on the scope (e.g. stage,theme,app).
     * empty if the scope is not having param.
     * @memberof EkstepRendererAPI
     */
    getParams: function(scope) {
        var paramData = '';
        if (scope === 'theme') {
            paramData = Renderer.theme._contentParams;
        }
        if (scope === 'stage') {
            paramData = EkstepRendererAPI.getStageParam();
        }
        if (scope === 'app') {
            paramData = GlobalContext._params;
        }
        return paramData;
    },

    /**
     * Returns stageData for particular stage identifier.
     * undefined if the stage data is not present for the particular stage identfier.
     * this could be usefull when plugin wants to fetch some paticular stage data.
     * @param stageId {string} name of the identifier.
     * @memberof EkstepRendererAPI
     */
    getStage: function(stageId) {
        return Renderer.theme.getStageDataById(stageId);
    },

    /**
     * Returns state of the param.
     * Undefined if the param is not present is the currentState.
     * @param paramName {string} name of the param.
     * @memberof EkstepRendererAPI
     */
    getState: function(paramName) {
        var currentStage = EkstepRendererAPI.getCurrentStage();
        if (currentStage) {
            return currentStage.getState(paramName);
        }
    },

    /*--------------------------*/

    /**
     * It takes the value and the param to set its state
     * @param param {string} Param is a string defining the type of question (mcq/mtf/ftb)
     * @param value {object/array} value for mcq and mtf type is an array and for ftb type is an object
     * @param isStateChanged {boolean} state true or false if pluginState is changed
     * @memberof EkstepRendererAPI
     **/
    setState: function(param, value, isStateChanged) {
        var currentStage = EkstepRendererAPI.getCurrentStage();
        if (currentStage) {
            currentStage.setState(param, value, isStateChanged);
        }
    },

    /**
     * It takes the action as an object and invokes to the renderer
     * @param action {object} pass the complete object required format to execute the actoin
     * @memberof EkstepRendererAPI
     **/
    invokeAction: function(action) {
        CommandManager.handle(action);
    },

    /**
     * Returns the complete telemetryService instance
     * @memberof EkstepRendererAPI
     **/
    getTelemetryService: function() {
        return TelemetryService;
    },

    /**
     * Returns the complete Telemetry data obj.
     * This could be usefull when plugin get access to know the telemetry data for the current content.
     * @memberof EkstepRendererAPI
     **/
    getTelemetryData: function() {
        return TelemetryService._data;
    },

    /**
     * Returns the instance of the plugin
     * @param id {string} id is a string defining the name of the plugin
     * @param data {object} data to instantiate plugin
     * @param parent {object} state parent instance
     * @memberof EkstepRendererAPI
     **/
    instantiatePlugin: function(id, data, parent) {
        return PluginManager.invoke(id, data, parent, Renderer.theme._currentScene, Renderer.theme);
    },

    /**
     * Transition command executes with given stage id
     * @param stageId {string} Moves to given stage id
     * @memberof EkstepRendererAPI
     **/
    tansitionTo: function(stageId) {
        var props = {
            "duration": "100",
            "ease": "linear",
            "effect": "fadeIn",
            "value": stageId,
            "pluginId": Renderer.theme._id,
            "transitionType": "next"
        };
        this.invokeCommand("transitionTo", Renderer.theme._id, props);
    },

    /**
     * Returns the complete Game area
     * @memberof EkstepRendererAPI
     **/
    getGameArea: function() {
        return document.getElementById('gameArea');;
    },

    /**
     * Returns the asset/media instance of Image, Audio, video etc.. which is defined in the manifest of the given assetId
     * @param assetId {string} assetId of the desired asset/media defined in manifest
     * @memberof EkstepRendererAPI
     **/
    getAsset: function(assetId) {
        return AssetManager.strategy.assetMap[assetId];
    },

    /**
     * Loads the asset of teh given assetId
     * @param assetId {string} assetId of the desired asset
     * @memberof EkstepRendererAPI
     **/
    loadAsset: function(assetId) {
        var asset = AssetManager.strategy.assetMap[assetId];
        return AssetManager.loadAsset(Renderer.theme._currentStage, asset.id, asset.src);
    },

    /**
     * It will play any type of asset by passing respective assetId (e.g. video, audio).
     * @assetId {string} identifier of the asset.
     * @memberof EkstepRendererAPI
     **/
    play: function(assetId) {
        this.invokeCommand("play", assetId);
    },

    /**
     * It will pause any asset by passing respective assetId (e.g. video, audio).
     * @assetId {string} identifier of the asset.
     * @memberof EkstepRendererAPI
     **/
    pause: function(assetId) {
        this.invokeCommand("pause", assetId);
    },

    /**
     * It will stop any asset by passing respective assetId (e.g. video, audio).
     * @assetId {string} identifier of the asset.
     * @memberof EkstepRendererAPI
     **/
    stop: function(assetId) {
        this.invokeCommand("stop", assetId);
    },

    /**
     * It takes the assetId of the given audio and toggelPlays it.
     * @param action {string} assetId is received as a string
     * @memberof EkstepRendererAPI
     **/
    toggelPlay: function(assetId) {
        this.invokeCommand("togglePlay", assetId);
    },

    /**
     * This could be usefull when pluign wants to stop all currently playing audio on the stage.
     * @memberof EkstepRendererAPI
     **/
    stopAll: function() {
        this.invokeCommand("stop", "", {"sound": true});
    },

    /**
     * This could be usefull when pluign wants to Mute all currently playing audio on the stage.
     * @memberof EkstepRendererAPI
     **/
    muteAudio: function() {
        AudioManager.mute();
    },

    /**
     * This could be usefull when pluign wants to UnMute all currently playing audio on the stage.
     * @memberof EkstepRendererAPI
     **/
    unMuteAudio: function() {
        AudioManager.unmute();
    },

    /**
     * It starts recording with intake proper assetId
     * @param action {string} assetId is received as a string
     * @memberof EkstepRendererAPI
     **/
    startRecording: function(assetId) {
        var action = {
            "type": "command",
            "command": "startRecord",
            "asset": assetId,
            "disableTelemetry": false,
            "success": "recordingInfo",
            "stageInstanceId": Renderer.theme._currentScene._stageInstanceId,
            "stageId": Renderer.theme._currentStage
        };
        RecorderManager.startRecording(action);
    },

    /**
     * It stops recording with intake of proper assetId
     * @param action {string} assetId is received as a string
     * @memberof EkstepRendererAPI
     **/
    stopRecording: function(assetId) {
        var action = {
            "type": "command",
            "command": "stopRecord",
            "asset": assetId,
            "disableTelemetry": false,
            "success": "recordingInfo",
            "stageInstanceId": Renderer.theme._currentScene._stageInstanceId,
            "stageId": Renderer.theme._currentStage
        };
        RecorderManager.stopRecording(action);
    },

    /**
     * To execute a sepecific command on the given input assetId. For list of commands refer https://community.ekstep.in/specifications-guides/55-ecml-how-to-guide#defining-events-and-actions
     * @param name {string} command name which has to execute, ex: "play", "show", "blur",
     * @param assetId {string} media/asset on which this command has to execute
     * @param props {object} To pass additional properties of command(key-value pair object). Ex: {"duration": 200, "effect": linear}
     * @memberof EkstepRendererAPI
     **/
    invokeCommand: function(name, assetId, props) {
        var stageId = this.getCurrentStage()._id;
        if (_.isUndefined(assetId) || _.isEmpty(assetId))
            assetId = stageId;

        var action = {
            'type': 'command',
            'command': name,
            'asset': assetId,
            'pluginId': stageId
        }
        if (props) {
            _.extend(action, props);
        }
        this.invokeAction(action);
    },

    /**
     * Navigate to next stage. Incase of item stage navigates to next question
     * @memberof EkstepRendererAPI
     **/
    next: function() {
        EventBus.dispatch("actionNavigateNext", "next");
    },

    /**
     * Navigate to previous stage.
     * @memberof EkstepRendererAPI
     **/
    previous: function() {
        EventBus.dispatch("actionNavigatePrevious", "previous");
    },

    /**
     * Navigate to next stage without submitting the assessment answer. Skip the current question submission.
     * @memberof EkstepRendererAPI
     **/
    skip: function() {
        EventBus.dispatch("actionNavigateSkip", "skip");
    },

    /**
     * Adds a child to this plugin intance. This can be useful for composite scenarios.
     * @param pluginId {string} plugin id inside which child had to be added
     * @param child {object} child element which has to be added inside plugin(child is not a createjs/this._self element)
     * @memberof EkstepRendererAPI
     **/
    addChild: function(pluginId, child) {
        var plugin = this.getPluginInstance(pluginId);
        plugin.addChild(child._self, child);
        this.render();
    },

    /**
     * Removes a child from this plugin by child index. Use this to dynamically manage composite children.
     * @param pluginId {string} plugin id from which child has to be removed
     * @param index {Number} index of createjs element object
     * @memberof EkstepRendererAPI
     **/
    removeChildAt: function(pluginId, index) {
        var plugin = this.getPluginInstance(pluginId);
        plugin.removeChildAt(index);
        this.render();
    },

    /**
     * Removes a child from this plugin by child instance. Use this to dynamically manage composite children.
     * @param pluginId {string} plugin id from which child has to be removed
     * @param child {object} child element which has to be removed(child should not be createjs/this._self element)
     * @memberof EkstepRendererAPI
     **/
    removeChild: function(pluginId, child) {
        var plugin = this.getPluginInstance(pluginId);
        plugin.removeChild(child._self);
        this.render();
    },

    /**
     * To get plugin dimensions specified in ECML/JSON
     * @param pluginId {string} plugin id of element whose dimension is needed
     * @memberof EkstepRendererAPI
     **/
    dimensions: function(pluginId) {
        var plugin = this.getPluginInstance(pluginId);
        return plugin.dimensions();
    },

    /**
     * To get plugin dimensions relative to Canvas/device width & height also with respect to it's parents
     * @param pluginId {string} plugin id of element whose dimension is needed
     * @memberof EkstepRendererAPI
     **/
    relativeDims: function(pluginId) {
        var plugin = this.getPluginInstance(pluginId);
        return plugin.relativeDims();
    },

    /**
     * property of the plugin to show it's visiblity on stage
     * @param assetId {string} assetId of element to show
     * @param delay {number} [0] delay before action happened (optional)
     * @memberof EkstepRendererAPI
     **/
    show: function(assetId, delay) {
        var props = {
            'delay' : delay ? delay : 0,
        }
        this.invokeCommand('show', assetId, props);
    },

    /**
     * Property of the plugin to hide it's visiblity on stage
     * @param assetId {string} assetId of element to hide
     * @param delay {number} [0] delay before action happened (optional)
     * @memberof EkstepRendererAPI
     **/
    hide: function(assetId, delay) {
        var props = {
            'delay' : delay ? delay : 0,
        }
        this.invokeCommand('hide', assetId, props);
    },

    /**
     * property of the plugin to toggle it's visiblity on stage
     * @param assetId {string} assetId of element to toggle
     * @param delay {number} [0] delay before action happened (optional)
     * @memberof EkstepRendererAPI
     */
    toggleShow: function(assetId, delay) {
        var props = {
            'delay' : delay ? delay : 0,
        }
        this.invokeCommand('toggleShow', assetId, props);
    },

    /**
     * property of the plugin to toggle it's shadow
     * @param pluginId {string} plugin id of element whose shadow has to be toggled
     * @memberof EkstepRendererAPI
     */
    toggleShadow: function(pluginId) {
        var plugin = this.getPluginInstance(pluginId);
        plugin.toggleShadow();
    },

    /**
     * property of the plugin to add shadow using createJS shadow property
     * @param pluginId {string} plugin id of element whose shadow should be added
     * @memberof EkstepRendererAPI
     */
    addShadow: function(pluginId) {
        var plugin = this.getPluginInstance(pluginId);
        plugin.addShadow();
    },

    /**
     * property of the plugin to remove it's shadow
     * @param pluginId {string} plugin id of element whose shadow should be removed
     * @memberof EkstepRendererAPI
     */
    removeShadow: function(pluginId) {
        var plugin = this.getPluginInstance(pluginId);
        plugin.removeShadow();
    },

    /**
     * Returns the boolean which show if element has shawdow enabled or not.
     * @param pluginId {string} plugin id of element whose shadow needs to be findout
     * @memberof EkstepRendererAPI
     */
    hasShadow: function(pluginId) {
        var plugin = this.getPluginInstance(pluginId);
        return plugin.hasShadow();
    },

    /**
     * Draw a border on element
     * @param pluginId {string} plugin id of element border should be drawn
     * @param dims {object} dimension of border to be drawed
     * @memberof EkstepRendererAPI
     */
    drawBorder: function(pluginId, dims) {
        var plugin = this.getPluginInstance(pluginId);
        plugin.drawBorder(plugin, dims);
    },

    /**
     * Rotate an element
     * @param pluginId {string} plugin id of element to be rotated
     * @param rotate {integer} angle through which plugin will be rotated(0 to 360)
     * @memberof EkstepRendererAPI
     */
    rotation: function(pluginId, rotate) {
        var plugin = this.getPluginInstance(pluginId);
        plugin.rotate = rotate;
        plugin.rotation(plugin);
    },

    /**
     * Blur the element
     * @param pluginId {string} plugin id of element to be blurred
     * @memberof EkstepRendererAPI
     */
    blur: function(pluginId) {
        var plugin = this.getPluginInstance(pluginId);
        plugin.blur();
    },

    /**
     * Unblur the current element
     * @param pluginId {string} plugin id of element to be unblurred
     * @memberof EkstepRendererAPI
     */
    unblur: function(pluginId) {
        var plugin = this.getPluginInstance(pluginId);
        plugin.unblur();
    },

    /**
     * Invoke childrens again to reflect changes
     * @param scope {object} this variable (use this variable)
     * @memberof EkstepRendererAPI
     */
    invokeChildren: function(pluginId, scope) {
        var plugin = this.getPluginInstance(pluginId);
        plugin.invokeChildren(scope, scope._parent, scope._stage, scope._theme);
    },

    /**
     * Returns the asset/media object of Image, Audio, video etc from ecml.. which is defined in the manifest of the given assetId
     * @param assetId {string} assetId of the desired asset/media defined in manifest
     * @memberof EkstepRendererAPI
     **/
    getMedia: function(assetId) {
        return Renderer.theme.getMedia(assetId);
    },
    /**
     *This api is going to return you the current stage question item
     *@memberof EkstepRendererAPI
     */
    currentItem: function() {
        var ctrl = this.getCurrentController();
        return ctrl._model[ctrl._index];
    },
    /**
     *This api is going to return you the previous stage question item
     *@memberof EkstepRendererAPI
     */
    previousItem: function() {
        var ctrl = this.getCurrentController();
        if (ctrl._index > 0 && ctrl._index < ctrl._model.length) return ctrl._model[ctrl._index - 1];
        return 'Item not available';
    },
    /**
     * Merge two stages into single stage and return the final stage.
     * @param stage1 {object} Stage1 data to be merged with another stage.
     * @param stage2 {object} Stage2 data to be merged with another stage.
     * @memberof EkstepRendererAPI
     **/
    mergeStages: function(stage1, stage2) {
        return Renderer.theme.mergeStages(stage1, stage2);
    },
    /**
     *This api is going to return you the complete item list in the stage
     *@memberof EkstepRendererAPI
     */
    getStageItems: function() {
        var currentController = EkstepRendererAPI.getCurrentController();
        if (currentController && currentController._model) return currentController._model;
        return "Item not available."
    },

   /**
    *This api is going to return you the external plugin obj
    *@memberof EkstepRendererAPI
    */
   getGlobalConfig: function() {
       return window.globalConfig;
   },

   /**
    *This api will replay the content from start
    * @memberof EkstepRendererAPI
    * @param data {object} event data to carry along with the notification
    * @param target {object} the scope of the event (use this)
    */
   replayContent: function(data, target) {
       EkstepRendererAPI.dispatchEvent('actionReplay', data, target);
   },

   /**
    * This api will return the current user on the Device
    * @memberof EkstepRendererAPI
    */
   getCurrentUser: function() {
       EkstepRendererAPI.dispatchEvent('event:getcurrentuser');
       return currentUser;
    },

   /**
    * This api will return the list of users on the Device
    * @memberof EkstepRendererAPI
    */
   getAllUserProfile: function() {
       EkstepRendererAPI.dispatchEvent('event:getAllUserProfile');
       return userList;
    },

   /**
    * This api will show or hide the user switcher module
    * @memberof EkstepRendererAPI
    * @param value {boolean} true/false to show/hide the user
    */
   showUser: function(value) {
       EkstepRendererAPI.dispatchEvent('event:showuser', value);
   },

   /**
    * This api will turn on/off the user switching
    * @memberof EkstepRendererAPI
    * @param value {boolean} true/false to show/hide the user
    */
   enableUserSwitcher: function(value) {
       EkstepRendererAPI.dispatchEvent('event:enableUserSwitcher', value);
   },

   /**
    * This api will close the user switcher modal
    * @memberof EkstepRendererAPI
    */
   openUserSwitcher: function() {
       EkstepRendererAPI.dispatchEvent('event:openuserswitcher');
   },

   /**
    * This api close the user switcher modal
    * @memberof EkstepRendererAPI=
    */
   closeUserSwitcher: function() {
       EkstepRendererAPI.dispatchEvent('event:closeuserswitcher');
   },

    /**
    *This api will Generate the OE_ERROR Telemetry event
    * @memberof EkstepRendererAPI
    * @param errorStack {object} event data to carry along with the notification
    * @param data {object} the object which need to log in Error event
    */

    logErrorEvent: function(errorStack, data) {
        try {
            if (data) {
                data.env = "undefined" != typeof cordova ? 'mobile' : EkstepRendererAPI.getGlobalConfig().context.mode || 'preview';
                data.type = !_.isUndefined(data.type) ? data.type.toUpperCase() : 'OTHER';
                data.stageId = this.getCurrentStageId();
                if (!data.objectType) {
                    data.objectType = !_.isUndefined(this.getPluginInstance(data.asset)) ? this.getPluginInstance(data.asset)._data.pluginType : '';
                }
                if (data.severity !== 'fatal') {
                    if (data.objectType === 'theme' || data.objectType === 'stage' || data.action === 'transitionTo') {
                        data.severity = 'fatal';
                    } else {
                        data.severity = 'error';
                    }
                }
                if (errorStack) {
                    data.err = errorStack.message || errorStack;
                    data.data = errorStack.stack;
                }
                EkstepRendererAPI.getTelemetryService().error(data);
            }
        } catch (e) {
            console.warn('OE_ERROR event fails to log',e);
        }

    },
    /**
    * API to set Renderer object
    * @memberof EkstepRendererAPI
    */
    setRenderer: function(data){
        Renderer = data;
    },
    /**
    * API to get Renderer object
    * @memberof EkstepRendererAPI
    */
    getRenderer: function(){
        return Renderer;
    },
    /**
     * API to Resolve plugin resource URL. This API would resolve to the repo the plugin is loaded from.
     *
     * @param  {String} pluginId      Plugin ID
     * @param  {String} pluginVersion Plugin Version
     * @param  {String} resource resource relative URL
     * @return {String}          Resolved URL
     * @memberof EkstepRendererAPI
     */
    resolvePluginResource: function (id, ver, resource) {
         return org.ekstep.pluginframework.pluginManager.resolvePluginResource(id, ver, resource);
    },
    /**
    * This to show the canvas endpage
    * @memberof EkstepRendererAPI
    */
    showEndPage:function(){
        this.dispatchEvent('renderer:content:end');
        this.dispatchEvent('renderer:endpage:show');
    },


    hideEndPage: function() {
       this.dispatchEvent('renderer:endpage:hide');
    },

    /**
    * API to retrun the rendrere service where user can acccess the
    * renderer services
    * @memberof EkstepRendererAPI
    */
    getService: function(){
        return org.ekstep.service.content;
    },

    /**
    * API to hide next navigation button
    * @memberof EkstepRendererAPI
    */
    hideNextNavigation: function(){
        EkstepRendererAPI.dispatchEvent('renderer:next:hide');
    },

    /**
    * API to show next navigation button
    * @memberof EkstepRendererAPI
    */
    showNextNavigation: function(){
        EkstepRendererAPI.dispatchEvent('renderer:next:show');
    },

    /**
    * API to hide previous navigation button
    * @memberof EkstepRendererAPI
    */
    hidePreviousNavigation: function(){
        EkstepRendererAPI.dispatchEvent('renderer:previous:hide');
    },

    /**
    * API to show previous navigation button
    * @memberof EkstepRendererAPI
    */
    showPreviousNavigation: function(){
        EkstepRendererAPI.dispatchEvent('renderer:previous:show');
    },

    /**
    * API to clear all createjs element from canvas
    * @memberof EkstepRendererAPI
    */
    clearStage: function(){
        if (!_.isUndefined(Renderer) && !_.isUndefined(Renderer.theme)) {
            Renderer.theme.clearStage();
        }
    },
    /**
    * Remove all Html elements from game area
    * @memberof EkstepRendererAPI
    */
    removeHtmlElements: function() {
        var gameAreaEle = jQuery('#' + Renderer.divIds.gameArea);
        var chilElemtns = gameAreaEle.children();
        jQuery(chilElemtns).each(function() {
            if ((this.id !== "overlay") && (this.id !== "gameCanvas")) {
                jQuery(this).remove();
            }
        });
    }

}

/**
 * @author Manjunath Davanam <manjunathd@ilimi.in>
 */
/**
 * Name space being fallowd
 * org.ekstep which is already defined in the pluginframework
 * reusing the same namespace
 */
var content_renderer = function() {};
content_renderer.prototype._ = window._;
window.org.ekstep.contentrenderer = new content_renderer();
window.globalConfig = {
    'context': {},
    'config': {}
};
org.ekstep.contentrenderer.init = function() {
    /**
     * TODO: Need To handle Synchronus flow of org.ekstep.contentrenderer.getContent and setContent here
     * device and web rendrer should be handle here
     */
    window.initializePreview = org.ekstep.contentrenderer.initializePreview;
    window.setContentData = org.ekstep.contentrenderer.setContent;
};

/**
 * Loading of canvas default plguis which are defined in the globalconfig obj
 */
org.ekstep.contentrenderer.loadDefaultPlugins = function(cb){
    org.ekstep.contentrenderer.initPlugins('', 'coreplugins');
    var globalConfig = EkstepRendererAPI.getGlobalConfig();
    org.ekstep.contentrenderer.loadPlugins(globalConfig.defaultPlugins,[],function(){
        if(cb) cb()
    });
};

/**
 * Is the starting point of the game. Before launching the game it loads the canvas 
 * default and external plugin and then initializes the player "renderer:player:init"
 * @param  {[obj]} appInfo [metadata]
 */
org.ekstep.contentrenderer.startGame = function(appInfo) {
    org.ekstep.contentrenderer.loadDefaultPlugins(function() {
        org.ekstep.contentrenderer.loadExternalPlugins(function() {
            var globalConfig = EkstepRendererAPI.getGlobalConfig();
            if (globalConfig.mimetypes.indexOf(appInfo.mimeType) > -1) {
                /**
                 * 'renderer.player.init' event will get dispatch after loading default & external injected plugins
                 * @event 'renderer.player.init'
                 * @fires 'renderer.player.init'
                 * @memberof EkstepRendererEvents
                 */
                EkstepRendererAPI.dispatchEvent('renderer:player:init');
            } else {
                if(!isbrowserpreview){
                    // TODO : Need to clean
                    org.ekstep.contentrenderer.loadPlugins({"id": "org.ekstep.collection", "ver": "1.0", "type": 'plugin'}, [], function(){
                         EkstepRendererAPI.dispatchEvent('renderer:collection:show');
                    });  
                }else{
                    console.log("SORRY COLLECTION PREVIEW IS NOT AVAILABEL");
                }
            }
        });
    });
};
/**
 * To create a multiple repo instance to load the plugins
 * If the repo path is undefined then framework is considering default paths
 */
org.ekstep.contentrenderer.addRepos = function() {
    var obj = EkstepRendererAPI.getGlobalConfig();
    if (_.isUndefined(obj.config.repos)) {
        obj.config.repos = isMobile ? obj.devicePluginspath : obj.previewPluginspath;
    }
    EkstepRendererAPI.dispatchEvent("renderer:repo:create", undefined, {
        path: obj.config.repos,
        position: 0
    });    
};

/**
 * Loading of external plugins using plugin framework
 * Exteranal plguins can send through window confi obj
 */
org.ekstep.contentrenderer.loadExternalPlugins = function(cb) {
    var globalConfig = EkstepRendererAPI.getGlobalConfig();
    org.ekstep.contentrenderer.addRepos();
    if (globalConfig.config.plugins) {
        org.ekstep.contentrenderer.loadPlugins(globalConfig.config.plugins, [], function() {
            console.info('External plugins are loaded');
            if (cb) cb();
        });
    }else{
        if(cb) cb();
    }
};

org.ekstep.contentrenderer.setContent = function(metadata, data, configuration) {
    if (_.isUndefined(metadata) || _.isNull(metadata)) {
        content.metadata = AppConfig.defaultMetadata
    } else {
        content.metadata = metadata;
    }
    if (!_.isUndefined(data)) {
        content.body = data;
    }
    _.map(configuration, function(val, key) {
        config[key] = val;
    });
    if (!config.showHTMLPages) {
        config.showEndPage = false;
    }
    localStorageGC.clear();
    if (data) {
        var object = {
            'config': configuration,
            'data': data,
            'metadata': metadata
        }
    }
    org.ekstep.contentrenderer.initializePreview(object);
};

org.ekstep.contentrenderer.initializePreview = function(configuration) {
    if (_.isUndefined(configuration.context)) {
        configuration.context = {};
    }
    if (_.isUndefined(configuration.config)) {
        configuration.config = {};
    }
    if (_.isUndefined(configuration.context.contentId)) {
        configuration.context.contentId = getUrlParameter("id")
    }
    localStorageGC.clear();
    _.extend(configuration, configuration.context);  // TelemetryEvent is using globalConfig.context.sid/did
    _.extend(configuration, configuration.config);
    setGlobalConfig(configuration);

    addWindowUnloadEvent();
    /**
     * 'renderer.player.init' event will get dispatch after loading default & external injected plugins
     * @event 'renderer.player.init'
     * @fires 'renderer.player.init'
     * @memberof EkstepRendererEvents
     */
    EkstepRendererAPI.dispatchEvent("renderer.content.getMetadata");
};

/**
 * initialize of the plugin framework
 * @param  {[string]} host             [name of the domain or host ]
 * @param  {[string]} repoRelativePath [replative path]
 */
org.ekstep.contentrenderer.initPlugins = function(host, repoRelativePath) {
    var pluginsPath = undefined;
    // @ plugin:error event is dispatching from the plugin-framework
    // If any of the plugin is failed to load OR invoke then plugin:error event will trigger
    if (!EkstepRendererAPI.hasEventListener('plugin:error')) {
        EkstepRendererAPI.addEventListener('plugin:error', org.ekstep.contentrenderer.pluginError, this);
    }
    host = _.isUndefined(host) ? '' : host;
    var pluginRepo = host + repoRelativePath;
    var globalConfig = EkstepRendererAPI.getGlobalConfig();
    var pfConfig = {env: "renderer", async: async,build_number:globalConfig.version, pluginRepo: pluginRepo, repos: [org.ekstep.pluginframework.publishedRepo]
    };
    org.ekstep.pluginframework.initialize(pfConfig);
};

/**
 * Added the plguin error event if any of the plugin is failed then 
 * dispatching oE_ERROR event with data
 * @event plugin:error whihc is being dispatching from the plugin framework
 * @param  {[obj]} data  [data which is need to be log in the OE_ERROR Telemetry event]
 */
org.ekstep.contentrenderer.pluginError = function(event, data) {
    EkstepRendererAPI.logErrorEvent(data.err, {
        'type': 'plugin',
        'action': data.action,
        'objectType': data.plugin,
        'objectId': data.objectid
    });
};

/**
 * Loading of the plguins
 * @param  {[array]}   pluginManifest [Pluginmanifest which is need to be loaded]
 * @param  {[array]}   manifestMedia  [Its optional if any other manifest media need to be load it behaves same as plguinManifest]
 * @param  {Function} cb             [After loading of the plguins callback will be invoked]
 */
org.ekstep.contentrenderer.loadPlugins = function(pluginManifest, manifestMedia, cb) {
    var pluginObj = []
    if (!Array.isArray(pluginManifest)) {
        pluginObj.push(pluginManifest);
        pluginManifest = pluginObj;
    }
    _.each(pluginManifest, function(p) {
        p.ver = parseFloat(p.ver).toFixed(1);
    });
    org.ekstep.pluginframework.pluginManager.loadAllPlugins(pluginManifest, manifestMedia, function() {
        if (typeof PluginManager != 'undefined') {
            PluginManager.pluginMap = org.ekstep.pluginframework.pluginManager.plugins;
        }
        if (cb) cb();
    });
};

/**
 * Registering of the plugin dynamically using createjs initialize without plguinframework
 * It will initializes the instance of the plugin
 * @param  {[type]} id     [description]
 * @param  {[type]} plugin [description]
 * @return {[type]}        [description]
 */
org.ekstep.contentrenderer.registerPlguin = function(id, plugin) {
    org.ekstep.pluginframework.pluginManager._registerPlugin(id, undefined, plugin);
    if (typeof createjs !== "undefined")
        createjs.EventDispatcher.initialize(plugin.prototype);
};

/**
 * It will fetchs the content metaData
 * @param  {[string]}   id [Content Identifer]
 * @return {[object]}      [Content Metadata]
 */
org.ekstep.contentrenderer.getContentMetadata = function(id, cb) {
    org.ekstep.service.content.getContent(id)
        .then(function(data) {
            org.ekstep.contentrenderer.setContentMetadata(data, function() {
                if (!_.isUndefined(cb)) {
                    cb(data);
                }
            });
        })
        .catch(function(err) {
            console.info("contentNotAvailable : ", err);
            contentNotAvailable(err);
        });
};

org.ekstep.contentrenderer.setContentMetadata = function(contentData, cb) {
    var data = _.clone(contentData);
    content["metadata"] = data;
    GlobalContext.currentContentId = data.identifier;
    GlobalContext.currentContentMimeType = data.mimeType;
    if (_.isUndefined(data.localData)) {
        data.localData = _.clone(data.contentData);
    }
    if (_.isUndefined(data.contentData)) {
        data.localData = _.clone(contentData);
    } else {
        data = data.localData;
    }
    if ("undefined" == typeof cordova) {
        org.ekstep.contentrenderer.getContentBody(content.metadata.identifier);
    }
    if (cb) cb();
};

/**
 * It will fetches the content body.
 * @param  {contentId} id [Content identifier]
 * @return {[obj]}    [Content body]
 */
org.ekstep.contentrenderer.getContentBody = function(id) {
    var configuration = EkstepRendererAPI.getGlobalConfig();
    var headers = org.ekstep.contentrenderer.urlparameter;
    if (!_.isUndefined(configuration.context.authToken)) {
        headers["Authorization"] = 'Bearer ' + configuration.context.authToken;
    }
    org.ekstep.service.content.getContentBody(id, headers).then(function(data) {
            content["body"] = data.body;
            org.ekstep.contentrenderer.startGame(content.metadata);
        })
        .catch(function(err) {
            console.info("contentNotAvailable : ", err);
            contentNotAvailable(err);
        });
};
org.ekstep.contentrenderer.urlparameter = function() {
    var urlParams = decodeURIComponent(window.location.search.substring(1)).split('&');
    var i = urlParams.length;
    while (i--) {
        if ((urlParams[i].indexOf('webview') >= 0) || (urlParams[i].indexOf('id') >= 0)) {
            urlParams.splice(i, 1)
        } else {
            urlParams[i] = urlParams[i].split("=");
        }
    }
    return (_.object(urlParams))
};

org.ekstep.contentrenderer.web = function(id) {
    var configuration = EkstepRendererAPI.getGlobalConfig();
    var headers = org.ekstep.contentrenderer.urlparameter;
    if (!_.isUndefined(configuration.context.authToken)) {
        headers["Authorization"] = 'Bearer ' + configuration.context.authToken;
    }
    org.ekstep.service.content.getContentMetadata(id, headers)
        .then(function(data) {
            org.ekstep.contentrenderer.setContentMetadata(data);
        })
        .catch(function(err) {
            console.info("contentNotAvailable : ", err);
            contentNotAvailable(err);
        });
};

org.ekstep.contentrenderer.device = function() {
    if (isMobile) {
        org.ekstep.contentrenderer.getContentMetadata(GlobalContext.game.id, function() {
            org.ekstep.contentrenderer.startGame(content.metadata);
        });
    } else {
        org.ekstep.contentrenderer.startGame(GlobalContext.config.appInfo);
    }
};

org.ekstep.contentrenderer.init();

/**
 * Base launcher will launches all launcher it porvides a common supports for all the launcher.
 * any launcher can overide the specific method to change the behavior.
 * @class org.ekstep.contentrenderer.baseLauncher
 * @author Manjunath Davanam <manjunathd@ilimi.in>
 */

org.ekstep.contentrenderer.baseLauncher = Class.extend({


/**
 * init of the launcher with the given data.
 * @param data {object} return the manifest object data
 * @memberof org.ekstep.contentrenderer.baseLauncher
 */
init:function(data) {
	EkstepRendererAPI.addEventListener("renderer:telemetry:end",this.endTelemetry, this);
	this.initialize(data);
},

/**
 * Initializes of the launcher with the given data.
 * @param data {object} return the manifest object data any launcher must extend initialize
 * method to load the launcher in globally
 * @memberof org.ekstep.contentrenderer.baseLauncher
 */

initialize:function(data){
	console.info('Base Launcher is intializd');
},

/**
 * launching of the particular launcher
 * @memberof org.ekstep.contentrenderer.baseLauncher
 */

launch:function(){
	console.info('Base Launcher should construct');
},


/**
 * relaunch of the particular launcher
 * @memberof org.ekstep.contentrenderer.baseLauncher
 */

relaunch: function() {
    console.info('Base Launcher should construct');
    var data = {};
	data.stageid = getCurrentStageId();
    data.mode = getPreviewMode();
    TelemetryService.start(GlobalContext.game.id, GlobalContext.game.ver, data);
},

/**
 * Clearing of the Lancher instace
 * @memberof org.ekstep.contentrenderer.baseLauncher
 */

clear:function(){
	console.info('Clearing the launcher instance')
},

progres: function(currentIndex, totalIndex) {
    var totalProgress = (currentIndex / totalIndex) * 100;
    totalProgress = totalProgress > 100 ? 100 : totalProgress;
    return Math.round(totalProgress);
},
contentProgress:function(){
	console.warn("Child Launcher should calculate");
},
endTelemetry:function(event){
	if (TelemetryService.instance && TelemetryService.instance.telemetryStartActive()) {
		var telemetryEndData = {};
		telemetryEndData.stageid = getCurrentStageId();
		telemetryEndData.progress = this.contentProgress();
		console.info("telemetryEndData",telemetryEndData);
		TelemetryService.end(telemetryEndData);
	} else {
		console.warn('Telemetry service end is already logged Please log start telemetry again');
	}

}

});

/**
 * Base endpage will get launched at the end of all stages.
 * Any plugin can overide the specific method to change the endpage behavior.
 * @class org.ekstep.contentrenderer.baseEndepage
 * @author Krushanu Mohapatra <krushanu.mohapatra@tarento.com>
 */

org.ekstep.contentrenderer.baseEndepage = Plugin.extend({

	_isAvailable: false,

/**
* init of the launcher with the given manifest as data.
* @param data {object} return the manifest object data any launcher must extend initialize
* method to load the launcher in globally
* @memberof org.ekstep.contentrenderer.baseEndepage
*/
init: function(data, parent, stage, theme) {
	var instance = this;
	this._isAvailable = true;
	/**
     * 'renderer:content:end' event will get dispatch once content ends (i.e. Once all stages/game is ends)
     * @example
     * It will be usefull to show endpage or perform some action once the content is ended.
     * @event 'renderer:content:end'
     * @fires 'renderer:content:end'
     * @memberof EkstepRendererEvents
     */
	EkstepRendererAPI.addEventListener("renderer:content:end", instance.contentEnd, instance);
	this.initialize(data);
},

/**
* Initializes of the launcher with the given data.
* @param data {object} return the manifest object data any launcher must extend initialize
* method to load the launcher in globally
* @memberof org.ekstep.contentrenderer.baseEndepage
*/
initialize: function(data) {
	console.info('Base endepage is intializd');
},


/**
 * end of content listener
 * @memberof org.ekstep.contentrenderer.baseEndepage
 */
contentEnd: function(evnt, instance) {
	if (this._isAvailable) {
		EkstepRendererAPI.dispatchEvent("renderer:overlay:hide");
		EkstepRendererAPI.dispatchEvent("renderer:player:hide");
	} else {
	}
},

/**
 * Clearing of the Lancher instace
 * @memberof org.ekstep.contentrenderer.baseEndepage
 */

clear: function() {
	console.info('Clearing the launcher instance')
}

});

/**
 * @author Manjunath Davanam <manjunathd@ilimi.in>
 */
org.ekstep.service.controller = new(org.ekstep.service.mainService.extend({
	loadModules: undefined,
	loadTemplates: undefined,
    callback: undefined,
	init:function(){
	},
	initService: function(loadModuleFn) {
        this.loadModules = loadModuleFn;
    },
    loadNgModules: function(templatePath, controllerPath, callback) {
        this.loadModules && this.loadModules(templatePath, controllerPath, callback);
    },
    injectTemplate:function(injectTemplatesFn){
    	this.loadTemplates = injectTemplatesFn;
    },
    inject:function(templatePath, toElement){
    	this.loadTemplates && this.loadTemplates(templatePath, toElement);
    }
}));
/**
 * List of events dispaching by GenieCanvas renderer.
 * any plugin can register for these events to perform specific action in plugin
 *
 * @class EkstepRendererEvents
 * @author Vinu Kumar V.S <vinu.kumar@tarento.com>
 */
org.ekstep.contentrenderer.events = {
		
		/** 
		 * 'renderer.player.init' event will get dispatch after loading default & external injected plugins on GenieCanvas launch
		 * @memberof EkstepRendererEvents
		 */
		"renderer.player.init":  "renderer.player.init",
		/** 
		 * 'renderer.player.show' event will get dispatch after loading default & external injected plugins on GenieCanvas launch
		 * @memberof EkstepRendererEvents
		 */
		"renderer.player.show":  "renderer.player.show",
		/** 
		 * 'renderer.player.init' event will get dispatch after loading default & external injected plugins on GenieCanvas launch
		 * @memberof EkstepRendererEvents
		 */
		"renderer.player.hide":  "renderer.player.hide",
		/** 
		 * 'renderer.player.show' event will get dispatch after loading default & external injected plugins on GenieCanvas launch
		 * @memberof EkstepRendererEvents
		 */
		"renderer.player.show":  "renderer.player.show",

		/**
		 * 'renderer:content:end' event will get dispatch once content is ended.
		 * @memberOf EkstepRendererEvents
		 */
		"renderer.content.end":  "renderer.player.end",

		/**
		 * 'backbuttonpressed' event will get dispatch once device back button is pressed
		 * @memberOf EkstepRendererEvents
		 */
		"renderer:device:back": "renderer:device:back"

};

EkstepRendererEvents = org.ekstep.contentrenderer.events;