/* Simple JavaScript Inheritance
 * By John Resig http://ejohn.org/
 * MIT Licensed.
 */
// Inspired by base2 and Prototype
(function() {
    var initializing = false,
        fnTest = /xyz/.test(function() {
            xyz;
        }) ? /\b_super\b/ : /.*/;

    // The base Class implementation (does nothing)
    this.Class = function() {};

    // Create a new Class that inherits from this class
    Class.extend = function(prop) {
        var _super = this.prototype;

        // Instantiate a base class (but only create the instance,
        // don't run the init constructor)
        initializing = true;
        var prototype = new this();
        initializing = false;

        // Copy the properties over onto the new prototype
        for (var name in prop) {
            // Check if we're overwriting an existing function
            prototype[name] = typeof prop[name] == "function" &&
                typeof _super[name] == "function" && fnTest.test(prop[name]) ?
                (function(name, fn) {
                    return function() {
                        var tmp = this._super;

                        // Add a new ._super() method that is the same method
                        // but on the super-class
                        this._super = _super[name];

                        // The method only need to be bound temporarily, so we
                        // remove it when we're done executing
                        var ret = fn.apply(this, arguments);
                        this._super = tmp;

                        return ret;
                    };
                })(name, prop[name]) :
                prop[name];
        }

        // The dummy class constructor
        function Class() {
            // All construction is actually done in the init method
            if (!initializing && this.init)
                this.init.apply(this, arguments);
        }

        // Populate our constructed prototype object
        Class.prototype = prototype;

        // Enforce the constructor to be what we expect
        Class.prototype.constructor = Class;

        // And make this class extendable
        Class.extend = arguments.callee;

        return Class;
    };
})();
var dateFormat = function () {
    var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g,
        timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
        timezoneClip = /[^-+\dA-Z]/g,
        pad = function (val, len) {
            val = String(val);
            len = len || 2;
            while (val.length < len) val = "0" + val;
            return val;
        };

    // Regexes and supporting functions are cached through closure
    return function (date, mask, utc) {
        var dF = dateFormat;

        // You can't provide utc if you skip other args (use the "UTC:" mask prefix)
        if (arguments.length == 1 && Object.prototype.toString.call(date) == "[object String]" && !/\d/.test(date)) {
            mask = date;
            date = undefined;
        }

        // Passing date through Date applies Date.parse, if necessary
        date = date ? new Date(date) : new Date;
        if (isNaN(date)) throw SyntaxError("invalid date");

        mask = String(dF.masks[mask] || mask || dF.masks["default"]);

        // Allow setting the utc argument via the mask
        if (mask.slice(0, 4) == "UTC:") {
            mask = mask.slice(4);
            utc = true;
        }

        var _ = utc ? "getUTC" : "get",
            d = date[_ + "Date"](),
            D = date[_ + "Day"](),
            m = date[_ + "Month"](),
            y = date[_ + "FullYear"](),
            H = date[_ + "Hours"](),
            M = date[_ + "Minutes"](),
            s = date[_ + "Seconds"](),
            L = date[_ + "Milliseconds"](),
            o = utc ? 0 : date.getTimezoneOffset(),
            flags = {
                d:    d,
                dd:   pad(d),
                ddd:  dF.i18n.dayNames[D],
                dddd: dF.i18n.dayNames[D + 7],
                m:    m + 1,
                mm:   pad(m + 1),
                mmm:  dF.i18n.monthNames[m],
                mmmm: dF.i18n.monthNames[m + 12],
                yy:   String(y).slice(2),
                yyyy: y,
                h:    H % 12 || 12,
                hh:   pad(H % 12 || 12),
                H:    H,
                HH:   pad(H),
                M:    M,
                MM:   pad(M),
                s:    s,
                ss:   pad(s),
                l:    pad(L, 3),
                L:    pad(L > 99 ? Math.round(L / 10) : L),
                t:    H < 12 ? "a"  : "p",
                tt:   H < 12 ? "am" : "pm",
                T:    H < 12 ? "A"  : "P",
                TT:   H < 12 ? "AM" : "PM",
                Z:    utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""),
                o:    (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
                S:    ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
            };

        return mask.replace(token, function ($0) {
            return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);
        });
    };
}();

// Some common format strings
dateFormat.masks = {
    "default":      "ddd mmm dd yyyy HH:MM:ss",
    shortDate:      "m/d/yy",
    mediumDate:     "mmm d, yyyy",
    longDate:       "mmmm d, yyyy",
    fullDate:       "dddd, mmmm d, yyyy",
    shortTime:      "h:MM TT",
    mediumTime:     "h:MM:ss TT",
    longTime:       "h:MM:ss TT Z",
    isoDate:        "yyyy-mm-dd",
    isoTime:        "HH:MM:ss",
    isoDateTime:    "yyyy-mm-dd'T'HH:MM:ss",
    isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
};

// Internationalization strings
dateFormat.i18n = {
    dayNames: [
        "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat",
        "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
    ],
    monthNames: [
        "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
        "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
    ]
};

// For convenience...
Date.prototype.format = function (mask, utc) {
    return dateFormat(this, mask, utc);
};
InActiveEvent = Class.extend({
    init: function() {},
    ext: function() {return this;},
    flush: function() {},
    __noSuchMethod__: function() {
        console.log('TelemetryService is inActive');
        return this;
    }
})
TelemetryEvent = Class.extend({
    createdTime: undefined,
    _isStarted: false,
    startTime: 0,
    name: undefined,
    event: undefined,
    init: function(eid, version, body, user, gdata, cdata, otherData) {
        if("undefined" != gdata && "undefined" == gdata.ver)
            gdata.ver = "1";
        this.createdTime = getCurrentTime();
        this.name = eid;

        this.event = {
            ver: version,
            uid: user.uid,
            sid: (otherData) ? (otherData.sid || "") : "",
            did: (otherData) ? (otherData.did || "") : "",
            edata: {
                eks: body || {}
            },
            eid: eid,
            gdata: gdata,
            cdata: cdata
        };
        if(otherData){
            var otherKeys = Object.keys(otherData);
            for (var i=0; i<otherKeys.length; i++) {
                var keyName = otherKeys[i];

                var sourceObj = this.event[keyName];
                var targetObj = otherData[keyName];
                if (!_.isUndefined(sourceObj)) {
                    // data is already present
                    if(typeof(sourceObj) === 'object'){
                        // data is of type object or Array
                        if(Array.isArray(sourceObj)){
                            sourceObj.push(targetObj);;
                        } else {
                            Object.assign(sourceObj, targetObj);
                        }
                    } else {
                        // Data is of type 'string' or number
                        sourceObj = targetObj;
                    }
                } else if(!_.isUndefined(targetObj)){
                    // Data is not present
                    this.event[keyName] = targetObj;
                }
            }
        }
        TelemetryService._version == "1.0" ? this.event.ts = getTime(this.createdTime) : this.event.ets = getTime(this.createdTime);
    },
    flush: function(apiName) {
        var instance = this;
        if (this.event) {
            if ("undefined" != typeof telemetry) {
                TelemetryService.eventDispatcher('telemetryEvent', JSON.stringify(instance.event));
                telemetry.send(JSON.stringify(this.event), apiName).then(function() {
                    return JSON.stringify(this.event);
                }).catch(function(err) {
                    if(instance.event.uid){    // TODO Find the Unknow events from(Jquery/cordova/ionic)
                         TelemetryService.logError(instance.name, err);
                    }else{
                        console.warn("uid is not Present",instance.event);
                    }
                });
            } else {
                console.log(JSON.stringify(this.event));
            }
        }
    },
    ext: function(ext) {
        if (_.isObject(ext)) {
            if (this.event.edata.ext) {
                for (key in ext)
                    this.event.edata.ext[key] = ext[key];
            } else {
                this.event.edata.ext = ext;
            }
        }
        return this;
    },
    start: function() {
        this._isStarted = true;
        this.startTime = getCurrentTime();
        return this;
    },
    end: function(data) {
        if (this._isStarted) {
            var eks= {};
            // This method is called for access end as well. For OE_ASSESS it should not log "progress" data
            if(!_.isUndefined(data) && !_.isUndefined(data.progress)) {
                eks.progress = data.progress; // Default progress value is 50 later we need to remove
            }
            if (!_.isUndefined(data) && !_.isUndefined(data.stageid)) {
                eks.stageid = data.stageid; // attach stage id to eks
            }
            this.event.edata.eks.length = Math.round((getCurrentTime() - this.startTime ) / 1000);
            this.event.edata.eks.progress = eks.progress || undefined;
            this.event.edata.eks.stageid = eks.stageid || undefined;
            this.event.ets = new Date().getTime();
            this._isStarted = false;
            return this;
        } else {
            throw "can't end event without starting.";
        }
    }
});

TelemetryService = {
    _version: "2.1",
    _baseDir: 'EkStep Content App',
    isActive: false,
    _config: undefined,
    instance: undefined,
    gameOutputFile: undefined,
    _gameErrorFile: undefined,
    _gameData: undefined,
    _correlationData: undefined,
    _producerData: undefined,
    _otherData: undefined,
    _data: [],
    _gameIds: [],
    _user: {},
    apis: {
        telemetry: "sendTelemetry",
        feedback: "sendFeedback"
    },
    mouseEventMapping: {
        click: 'TOUCH',
        dblclick: 'CHOOSE',
        mousedown: 'DROP',
        pressup: 'DRAG'
    },
    init: function(gameData, user, correlationData, otherData) {
        var localStorageInstance = TelemetryService.getLocalStorageInstance();
        if (!_.isEmpty(localStorageInstance)) {
            TelemetryService.setTelemetryService(localStorageInstance, gameData);
        }
        return new Promise(function(resolve, reject) {
            if (!TelemetryService.instance) {
                TelemetryService._user = user;
                TelemetryService.instance = (TelemetryService._version == "1.0") ? new TelemetryV1Manager() : new TelemetryV2Manager();
                if (gameData) {
                    if (gameData.id && gameData.ver) {
                        TelemetryService._parentGameData = gameData;
                        TelemetryService._gameData = gameData;
                    } else {
                        reject('Invalid game data.');
                    }
                    TelemetryServiceUtil.getConfig().then(function(config) {
                        TelemetryService._config = config;
                        if (TelemetryService._config.isActive) TelemetryService.isActive = TelemetryService._config.isActive;
                        resolve(true);
                    }).catch(function(err) {
                        reject(err);
                    });
                } else {
                    reject('Game data is empty.');
                };
                if(correlationData && !_.isEmpty(correlationData)){
                    TelemetryService._correlationData = correlationData;
                };
                if(otherData && !_.isEmpty(otherData)){
                    TelemetryService._otherData = otherData;
                };
                resolve(true);
            } else {
                resolve(true)
                console.log("TelemetryService instance is not create")
            }
        });
    },
    webInit: function(gameData, user) {
        return new Promise(function(resolve, reject) {
            TelemetryService.init(gameData, user)
                .then(function() {
                    TelemetryService.start(gameData.id, gameData.ver);
                    resolve(true);
                })
                .catch(function(err) {
                    reject(err);
                });
        });
    },
    changeVersion: function(version) {
        TelemetryService._version = version;
        TelemetryService.instance = (TelemetryService._version == "1.0") ? new TelemetryV1Manager() : new TelemetryV2Manager();
        console.info("Telemetry Version updated to:", version);
    },
    getDataByField: function(field) {

    },
    getGameData: function() {
        return TelemetryService.isActive ? TelemetryService._gameData : undefined;
    },
    getInstance: function() {
        return TelemetryService.isActive ? TelemetryService.instance : undefined;
    },
    getMouseEventMapping: function() {
        return TelemetryService.mouseEventMapping;
    },
    getGameId: function() {
        return TelemetryService.isActive ? TelemetryService._gameData.id : undefined;
    },
    getGameVer: function() {
        return TelemetryService.isActive ? TelemetryService._gameData.ver : undefined;
    },
    exitWithError: function(error) {
        var message = '';
        if (error) message += ' Error: ' + JSON.stringify(error);
        TelemetryService.instance.exitApp();
    },
    flushEvent: function(event, apiName) {
        TelemetryService._data.push(event);
        if (event)
            event.flush(apiName);
        return event;
    },
    setTelemetryService: function(localStorageInstance, gameData) {
        // This is specific to HTML games launched by GenieCanvas
        // HTML content OE_START is already logged by GenieCanvas coverpage
        // OE_START should not log by HTML content once again(if they are using GenieCanvasBridge.js)
        if (localStorageInstance._gameData.id == gameData.id) {
            var start = localStorageInstance._start; //JSON.parse(localStorage.getItem("_start"));
            var end = localStorageInstance._end; //JSON.parse(localStorage.getItem("_end"));
            if (!_.isUndefined(localStorageInstance)) {
                for (var prop in localStorageInstance) {
                    if (TelemetryService.hasOwnProperty(prop)) {
                        TelemetryService[prop] = localStorageInstance[prop];
                    }
                }
            }
            TelemetryService.instance = (TelemetryService._version == "1.0") ? new TelemetryV1Manager() : new TelemetryV2Manager();
            if (!_.isUndefined(start)) {
                for (var i = 0; i < start.length; i++) {
                    TelemetryService.instance._start.push(start[i]);
                }
            }
            if (!_.isUndefined(end)) {
                var teEndevent = TelemetryService.instance.createEvent("OE_END", {}).start();
                var startTime = 0;
                if(end.length > 0){
                    startTime = end[end.length - 1].startTime;
                }
                teEndevent.startTime = startTime;
                TelemetryService.instance._end.push(teEndevent);
            }
        } else {
            console.info("Game id is not same", gameData.id);
        }
    },
    getLocalStorageInstance: function() {
        var telemetryLocalStorageData = localStorageGC.getItem("telemetryService");
            if(!_.isEmpty(telemetryLocalStorageData)){
                 telemetryLocalStorageData._start = JSON.parse(telemetryLocalStorageData._start);
                 telemetryLocalStorageData._end = JSON.parse(telemetryLocalStorageData._end);
        }
        return telemetryLocalStorageData;
    },
    start: function(id, ver, data) {
        if (!TelemetryService.isActive) {
            console.log("TelemetryService is not active.");
            return new InActiveEvent();
        } else {
            ver = (ver) ? ver + "" : "1"; // setting default ver to 1
            if (_.findWhere(TelemetryService.instance._start, {
                    id: id
                }))
                return new InActiveEvent();
            else
                return TelemetryService.flushEvent(TelemetryService.instance.start(id, ver, data), TelemetryService.apis.telemetry);
        }
    },
    end: function(data) {
        if (!TelemetryService.isActive) {
            return new InActiveEvent();
        }
        return this.flushEvent(TelemetryService.instance.end(data), TelemetryService.apis.telemetry);
    },
    interact: function(type, id, extype, data, eid) {
        if (!TelemetryService.isActive) {
            return new InActiveEvent();
        }
        return TelemetryService.flushEvent(TelemetryService.instance.interact(type, id, extype, data, eid), TelemetryService.apis.telemetry);
    },
    setUser: function(data, stageid, eid) {
        TelemetryService._user = data;
        data.stageId = stageid;
        TelemetryService.interact("TOUCH", "gc_userswitch", "TOUCH", data, eid);
    },
    assess: function(qid, subj, qlevel, data) {
        if (!TelemetryService.isActive) {
            return new InActiveEvent();
        }
        return TelemetryService.instance.assess(qid, subj, qlevel, data);
    },
    error: function(errorObj) {
        if (!TelemetryService.isActive) {
            return new InActiveEvent();
        }
        return TelemetryService.flushEvent(TelemetryService.instance.error(errorObj), TelemetryService.apis.telemetry);
    },
    assessEnd: function(event, data) {
        if (!TelemetryService.isActive) {
            return new InActiveEvent();
        }
        return TelemetryService.flushEvent(TelemetryService.instance.assessEnd(event, data), TelemetryService.apis.telemetry);
    },
    levelSet: function(eventData) {
        if (TelemetryService.isActive) {
            var eventName = 'OE_LEVEL_SET';
            return new InActiveEvent();
        }
    },
    interrupt: function(type, id, eid) {
        if (!TelemetryService.isActive) {
            return new InActiveEvent();
        }
        return TelemetryService.flushEvent(TelemetryService.instance.interrupt(type, id, eid), TelemetryService.apis.telemetry);
    },
    exitApp: function() {
        setTimeout(function() {
            navigator.app.exitApp();
        }, 5000);
    },
    navigate: function(stageid, stageto) {
        if (!TelemetryService.isActive) {
            return new InActiveEvent();
        }
        return TelemetryService._version == "1.0" ? "" : this.flushEvent(TelemetryService.instance.navigate(stageid, stageto), TelemetryService.apis.telemetry);
    },
    sendFeedback: function(eks) {
        if (!TelemetryService.isActive) {
            return new InActiveEvent();
        }
        return this.flushEvent(TelemetryService.instance.sendFeedback(eks), TelemetryService.apis.feedback);
    },
    xapi: function(eks) {
        if (!TelemetryService.isActive) {
            return new InActiveEvent();
        }
        return this.flushEvent(TelemetryService.instance.xapi(eks), TelemetryService.apis.telemetry);
    },
    itemResponse: function(data) {
        if (!TelemetryService.isActive) {
            return new InActiveEvent();
        }
        return TelemetryService.instance.itemResponse(data);
    },
    resume: function(newUserId, NewContentId, gameData, user) {
        var previousContentId = TelemetryService._gameData;
        var previousUserId = TelemetryService._user.uid;
        if (previousContentId != NewContentId || newUserId != previousUserId) {
            TelemetryService.end();
            TelemetryService.init(TelemetryService._gameData, TelemetryService._user);
            TelemetryService.start()
        }
    },
    exit: function(stageId) {
        if (TelemetryService.isActive) {
            TelemetryService._data = [];
            var data = {};
            data.stageid = stageId;
            if (!_.isEmpty(TelemetryService.instance._end)) {
                var len = TelemetryService.instance._end.length;
                for (var i = 0; i < len; i++)
                    TelemetryService.end(data);
            }
            if (_.isEmpty(TelemetryService.instance._end)) {
                TelemetryService.isActive = false;
            }
        }
    },
    logError: function(eventName, error) {
        var data = {
                'eventName': eventName,
                'message': error,
                'time': getCurrentTime()
            }
            // change this to write to file??
        console.log('TelemetryService Error:', JSON.stringify(data));
        // create the event and Dispatch the Event
        var evt = document.createEvent('Event');
        evt.initEvent('logError', true, true);
        document.body.dispatchEvent(evt);
        console.info('Telemetry :' + JSON.stringify(data.message));
    },
    print: function() {
        if (TelemetryService._data.length > 0) {
            var events = TelemetryService._data.cleanUndefined();
            events = _.pluck(events, "event");
            console.log(JSON.stringify(events));
        } else {
            console.log("No events to print.");
        }
    },
    eventDispatcher: function() {
        console.warn('Framework should handle dispatching of event by overwiting this function with dispatching event function');
    }
}

Array.prototype.cleanUndefined = function() {
    for (var i = 0; i < this.length; i++) {
        if (this[i] == undefined) {
            this.splice(i, 1);
            i--;
        }
    }
    return this;
};

TelemetryServiceUtil = {
    _config: {
        "isActive": true,
        "events": {
            "OE_INTERACT": {
                "eks": {
                    "type": {
                        "required": true,
                        "values": [
                            "TOUCH",
                            "DRAG",
                            "DROP",
                            "SPEAK",
                            "LISTEN",
                            "END",
                            "CHOOSE",
                            "OTHER"
                        ]
                    }
                }
            },
            "OE_INTERRUPT": {
                "eks": {
                    "type": {
                        "required": true,
                        "values": [
                            "BACKGROUND",
                            "IDLE",
                            "RESUME",
                            "SLEEP",
                            "CALL",
                            "SWITCH",
                            "LOCK",
                            "OTHER"
                        ]
                    }
                }
            }
        }
    },
    getConfig: function() {
        return new Promise(function(resolve, reject) {
            resolve(TelemetryServiceUtil._config);
        });
    }
}

// Generate Genie format ts as per Telemetry wiki
// https://github.com/ekstep/Common-Design/wiki/Telemetry
// YYYY-MM-DDThh:mm:ss+/-nn:nn
function getTime(ms) {
    var v = undefined;
    if (TelemetryService._version == "1.0") {
        var dte = new Date(ms);
        dte.setTime(dte.getTime() +(dte.getTimezoneOffset()+330)*60*1000);
        v = dateFormat(dte, "yyyy-mm-dd'T'HH:MM:ss")+"+05:30";
        return v;
    } else {
        v = new Date().getTime();
        return v;
    }
}

function getCurrentTime() {
    return new Date().getTime();
}
TelemetryV1Manager = Class.extend({
    _end: undefined,
    init: function() {
        console.info("TelemetryService Version 1 initialized.. ");
    },
    exitWithError: function(error) {
        var message = '';
        if (error) message += ' Error: ' + JSON.stringify(error);
        this.exitApp();
    },
    createEvent: function(eventName, body) {
        return new TelemetryEvent(eventName, TelemetryService._version, body, TelemetryService._user, TelemetryService._gameData);
    },
    start: function(id, ver) {
        TelemetryService._gameData = {id: id , ver : ver};
        this._end = this.createEvent("OE_END", {}).start();
        return this.createEvent("OE_START", {});
    },
    end: function(gameId) {
        return this._end.end();
    },
    interact: function(type, id, extype, data) {
        var ext = {
            stageid: data.stageId,
            x: data.x,
            y: data.y,
            choice_id: data.choice_id,
            drag_id: data.drag_id,
            itemId: data.itemId
        };
        var eventStr = TelemetryService._config.events["OE_INTERACT"];
        if (!_.contains(eventStr.eks.type.values, type)) {
            ext.type = type;
            type = "OTHER";
        }
        if(data.subtype == "PAUSE" || data.subtype == "STOP")
            type = data.subtype + "_LISTENING";
        if(data.subtype == "STOP_ALL")
            type = data.subtype + "_SOUNDS";
        var eks = {
            "type": type ? type : "",
            "id": id,
            "extype": type,
            "uri": ""
        };
        return this.createEvent("OE_INTERACT", eks).ext(ext);
    },
    assess: function(qid, subj, qlevel, data) {
        if (qid && subj && qlevel) {
            var eks = {
                qid: qid,
                subj: subj,
                qlevel: qlevel,
                mmc: [],
                mc: data.mc,
                maxscore: data.maxscore,
                params: []
            };
            return this.createEvent("OE_ASSESS", eks).start();
        } else {
            console.error("qid, subject, qlevel is required to create assess event.");
            return new InActiveEvent();
        }
    },
    assessEnd: function(eventObj, data) {
        if (eventObj) {

            if (!eventObj._isStarted) {
                eventObj._isStarted = true; // reset start status to true for re-assess events
            }

            eventObj.event.edata.eks.score = data.score || 0;
            eventObj.event.edata.eks.pass = data.pass ? 'Yes' : 'No';
            eventObj.event.edata.eks.res = data.res || [];
            eventObj.event.edata.eks.uri = data.uri || "";
            eventObj.event.edata.eks.qindex = data.qindex || 0;
            eventObj.end();
            return eventObj;
        }
    },
    interrupt: function(type, id) {
        var eventStr = TelemetryService._config.events["OE_INTERRUPT"];
        var eks = {
            "type": type,
            "id": id || ''
        };
        var ext = {};
        if (!_.contains(eventStr.eks.type.values, type)) {
            ext["type"] = type;
            type = "OTHER";
        }
        return this.createEvent("OE_INTERRUPT", eks).ext(ext);
    },
    exitApp: function() {
        setTimeout(function() {
            navigator.app.exitApp();
        }, 5000);
    }
});

TelemetryV2Manager = Class.extend({
    _end: new Array(),
    _start: new Array(),
     init: function() {
        console.info("TelemetryService Version 2 initialized..");
    },
    exitWithError: function(error) {
        var message = '';
        if (error) message += ' Error: ' + JSON.stringify(error);
        TelemetryServiceV2.exitApp();
    },
    createEvent: function(eventName, body) {
        return new TelemetryEvent(eventName, TelemetryService._version, body, TelemetryService._user, TelemetryService._gameData, TelemetryService._correlationData, TelemetryService._otherData);
    },
    start: function(id, ver, data) {
        TelemetryService._gameData = {id: id , ver : ver};
        this._end.push(this.createEvent("OE_END", {}).start());
        this._start.push({id: id , ver : ver});
        return this.createEvent("OE_START", data);
    },
    end: function(data) {
        if (this.telemetryStartActive()) {
            this._start.pop();
            if(data.progress == undefined) {
                // Bu default we are sending as 50. If any external guys called telemetryService.end() directly
                data.progress = 50;
            }
            return this._end.pop().end(data);
        } else {
            console.warn("Telemetry service end is already logged Please log start telemetry again");
        }
    },
    interact: function(type, id, extype, eks, eid) {
        if (eks.optionTag)
            TelemetryService.flushEvent(this.itemResponse(eks), TelemetryService.apis.telemetry);
        if (type != "DRAG") {
            var eks = {
                "stageid": eks.stageId ? eks.stageId : "",
                "type": type,
                "subtype": eks.subtype ? eks.subtype : "",
                "pos": eks.pos ? eks.pos : [],
                "id": id,
                "tid": eks.tid ? eks.tid : "",
                "uri": eks.uri ? eks.uri : "",
                "extype": "",
                "values": eks.values ? eks.values : []
            };
            var eventName = eid ? eid : "OE_INTERACT"
            return this.createEvent(eventName, eks);
        }
    },
    assess: function(qid, subj, qlevel, data) {
        var maxscore;
        subj = subj ? subj : "";
        if (data) {
            maxscore = data.maxscore || 1;
        }
        qlevel = qlevel ? qlevel : "MEDIUM";
        if (qid) {
            var eks = {
                qid: qid,
                maxscore: maxscore ,
                params: []
            };
            return this.createEvent("OE_ASSESS", eks).start();
        } else {
            console.error("qid is required to create assess event.", qid);
            // TelemetryService.logError("OE_ASSESS", "qid is required to create assess event.")
            return new InActiveEvent();
        }

    },
    error: function(data) {
        var data = {env: data.env || '', type: data.type || '', stageid: data.stageId || '', objecttype: data.objectType || '', objectid: data.objectId || '', err: data.err || '', action: data.action || '', data: data.data || '', severity: data.severity || ''}
        return this.createEvent("OE_ERROR", data);
    },
    assessEnd: function(eventObj, data) {
        if (eventObj) {

            if (!eventObj._isStarted) {
                eventObj._isStarted = true; // reset start status to true for re-assess events
            }

            eventObj.event.edata.eks.score = data.score || 0;
            eventObj.event.edata.eks.pass = data.pass ? 'Yes' : 'No';
            eventObj.event.edata.eks.resvalues = _.isEmpty(data.res)? [] : data.res;
            eventObj.event.edata.eks.uri = data.uri || "";
            eventObj.event.edata.eks.qindex = data.qindex || 0;
            eventObj.event.edata.eks.exlength = 0;
            eventObj.event.edata.eks.qtitle = data.qtitle;
            eventObj.event.edata.eks.qdesc = data.qdesc.substr(0,140);
            eventObj.event.edata.eks.mmc = data.mmc;
            eventObj.event.edata.eks.mc = data.mc;
            if (_.isArray(eventObj.event.edata.eks.resvalues)) {
                eventObj.event.edata.eks.resvalues = _.map(eventObj.event.edata.eks.resvalues, function(val) {
                    val = _.isObject(val) ? val :{"0" : val};
                    return val;
                });
            } else {
                eventObj.event.edata.eks.resvalues = [];
            }

            eventObj.end();
            return eventObj;
        }
    },
    interrupt: function(type, id, eid) {
            var eventStr = TelemetryService._config.events["OE_INTERRUPT"];
            var eks = {
                "type": type,
                "stageid": id || ''
            };
            var eventName = eid ? eid : "OE_INTERRUPT";
            return this.createEvent(eventName, eks);
    },
    exitApp: function() {
        setTimeout(function() {
            navigator.app.exitApp();
        }, 5000);
    },
    navigate: function(stageid, stageto) {
        if (stageto != undefined && stageid != undefined && stageto != stageid) {
            var eks = {
                stageid: stageid ? stageid : "",
                stageto: stageto ? stageto : "",
                type: "",
                itype: ""
            };
            return this.createEvent("OE_NAVIGATE", eks);
        }
    },
    itemResponse: function(data) {
        var type = data.optionTag == "MCQ" ? "CHOOSE" : "MATCH";
        var eks = {
                "qid": data.itemId ? data.itemId : "",
                "type": type ? type : "",
                "state": data.state ? data.state : "",
                "resvalues": _.isEmpty(data.res) ? [] : data.res
            };
        return this.createEvent("OE_ITEM_RESPONSE", eks);
    },
    sendFeedback: function(eks) {
        return this.createEvent("", eks);
    },
    telemetryStartActive: function() {
        return (!_.isEmpty(this._start));
    },
    xapi: function(data) {
        var eks = {xapi: data};
        return this.createEvent("OE_XAPI", eks);
    }
})
